local flags = {}
local library
local success, code = pcall(function() return readfile("UiLib.txt") end)

if success and code then
    print("Loading UiLib from local file...")
    library = loadstring(code)(flags)
else
    print("Loading UiLib from GitHub...")
    library = loadstring(game:HttpGet("https://raw.githubusercontent.com/hiddenassets5555/peppapig12dahood/refs/heads/main/test?t="..tostring(os.time())))(flags)
end

local uis = cloneref(game:GetService("UserInputService"))
local players = cloneref(game:GetService("Players"))
local ws = cloneref(game:GetService("Workspace"))
local http_service = cloneref(game:GetService("HttpService"))
local gui_service = cloneref(game:GetService("GuiService"))
local lighting = cloneref(game:GetService("Lighting"))
local run = cloneref(game:GetService("RunService"))
local stats = cloneref(game:GetService("Stats"))
local coregui = cloneref(game:GetService("CoreGui"))
local debris = cloneref(game:GetService("Debris"))
local tween_service = cloneref(game:GetService("TweenService"))
local sound_service = cloneref(game:GetService("SoundService"))
local starter_gui = cloneref(game:GetService("StarterGui"))
local rs = cloneref(game:GetService("ReplicatedStorage"))
local cas = cloneref(game:GetService("ContextActionService"))

local vec2 = Vector2.new
local vec3 = Vector3.new
local dim2 = UDim2.new
local dim = UDim.new 
local rect = Rect.new
local cfr = CFrame.new
local empty_cfr = cfr()
local point_object_space = empty_cfr.PointToObjectSpace
local angle = CFrame.Angles
local dim_offset = UDim2.fromOffset

local color = Color3.new
local hsv = Color3.fromHSV
local rgb = Color3.fromRGB
local hex = Color3.fromHex
local rgbseq = ColorSequence.new
local rgbkey = ColorSequenceKeypoint.new
local numseq = NumberSequence.new
local numkey = NumberSequenceKeypoint.new



-- [MOVED VARIABLES FOR ACCESS]
local IsCameraLockActive, IsRaycastActive, DeathCheckEnabled = false, false, false
local TargetFOV, selectedPart = 65, "Head"
local FOVCircle, FOVOutline, CurrentTarget
local FOVMiniDots = {}
local FOVColor, FOVAlpha = Color3.fromRGB(191, 191, 244), 1
local SilentTargetFOV = 65
local SilentFOVCircle, SilentFOVOutline
local SilentFOVMiniDots = {}
local SilentFOVColor, SilentFOVAlpha = Color3.fromRGB(191, 191, 244), 1
local DottedParams = { Num_Dots = 80, Dotted_Size = 1.5 }
local leftMouseDown = false
local SilentRate = 0.1
local USE_NAMECALL_HOOK = true
local shotRemote = nil
local ESP_SETTINGS = { Enabled = true }
local ESPRenderDistance = math.huge
local SCPRenderDistance = math.huge

-- [START] Staff Detection & Notification Logic
local GROUP_ID = 5479038
local STAFF_ROLES = {
    "Trial Moderator", "Game Moderator", "Senior Moderator", 
    "Head Moderator", "Developer", "Project Manager", 
    "Coordinator", "Administrator"
}
local STAFF_IDS = {
    [3227675780] = "Trial Moderator", [659057940] = "Trial Moderator", [89536296] = "Trial Moderator",
    [2868465341] = "Trial Moderator", [585910694] = "Trial Moderator", [362318824] = "Trial Moderator",
    [999399016] = "Trial Moderator", [4864589516] = "Trial Moderator",
    [362684820] = "Game Moderator", [1231547865] = "Game Moderator", [938606828] = "Game Moderator",
    [2481338650] = "Game Moderator", [3593562324] = "Game Moderator", [1469128513] = "Game Moderator",
    [470692996] = "Game Moderator", [527396508] = "Game Moderator", [447043949] = "Game Moderator",
    [409676514] = "Game Moderator", [1672865097] = "Game Moderator", [224151220] = "Game Moderator",
    [1272545109] = "Game Moderator", [495734376] = "Game Moderator", [934666178] = "Game Moderator",
    [954992466] = "Game Moderator", [289984168] = "Game Moderator", [1490009898] = "Game Moderator",
    [1733286024] = "Game Moderator", [155010418] = "Game Moderator", [90174430] = "Game Moderator",
    [914556394] = "Game Moderator", [2723679401] = "Game Moderator", [106374588] = "Game Moderator",
    [607285772] = "Game Moderator",
    [487753150] = "Senior Moderator", [2607536459] = "Senior Moderator", [196079740] = "Senior Moderator",
    [124271015] = "Senior Moderator",
    [342983833] = "Head Moderator", [888493] = "Head Moderator",
    [38152945] = "Administrator"
}

local activeStaff = {}
local savedFlags = {}

-- Define logic to block enabling features if staff is present
library.can_enable_feature = function()
    return #activeStaff == 0
end

local function RestoreFeatures()
    for k, v in pairs(savedFlags) do
        if library.config_flags and library.config_flags[k] then
            -- Use library setter to trigger callbacks (re-enables events)
            library.config_flags[k](v)
        elseif flags[k] ~= nil then
            if type(flags[k]) == "boolean" then
                flags[k] = v
            elseif type(flags[k]) == "table" and flags[k].active ~= nil then
                flags[k].active = v
            end
        elseif k == "IsCameraLockActive" then
             IsCameraLockActive = v
        elseif k == "IsRaycastActive" then
             IsRaycastActive = v
        elseif k == "DeathCheckEnabled" then
             DeathCheckEnabled = v
        elseif k == "ESP_Enabled" then
             if ESP_SETTINGS then ESP_SETTINGS.Enabled = v end
        end
    end
    table.clear(savedFlags)
    
    library:notification({
        text = "Staff Left. Features Restored.",
        time = 5
    })
end

local function DisableFeaturesAndNotify(player, roleName, reasonType)
    -- Track staff
    if not table.find(activeStaff, player) then
        table.insert(activeStaff, player)
    end

    -- Save state ONLY if this is the first staff member detected (and savedFlags is empty)
    if #activeStaff == 1 and next(savedFlags) == nil then
        for k, v in pairs(flags) do
            if type(v) == "boolean" then
                savedFlags[k] = v
            elseif type(v) == "table" and v.active ~= nil then
                savedFlags[k] = v.active
            end
        end
        -- Save global variables
        savedFlags["IsCameraLockActive"] = IsCameraLockActive
        savedFlags["IsRaycastActive"] = IsRaycastActive
        savedFlags["DeathCheckEnabled"] = DeathCheckEnabled
        if ESP_SETTINGS then savedFlags["ESP_Enabled"] = ESP_SETTINGS.Enabled end
    end

    -- Disable all flags using library setters if available
    for k, v in pairs(flags) do
        -- Only disable boolean flags (toggles)
        if type(v) == "boolean" then
            if library.config_flags and library.config_flags[k] then
                -- Use library setter to trigger callbacks (disconnects events)
                library.config_flags[k](false)
            else
                flags[k] = false
            end
        elseif type(v) == "table" and v.active ~= nil then
             v.active = false
        end
    end
    
    -- Disable global variables
    IsCameraLockActive = false
    IsRaycastActive = false
    DeathCheckEnabled = false
    if ESP_SETTINGS then ESP_SETTINGS.Enabled = false end

    -- Update Moderator List UI
    if library.add_moderator then
        library:add_moderator(player.Name, roleName, player.UserId)
    end

    -- Notify
    library:notification({
        text = "Staff Detected!\n" .. roleName .. " (" .. reasonType .. ")",
        time = 5
    })
end

local function CheckPlayer(plr)
    if not plr:IsDescendantOf(game.Players) then return end
    
    -- 1. Check Specific User IDs
    local hardcodedRole = STAFF_IDS[plr.UserId]
    if hardcodedRole then
        DisableFeaturesAndNotify(plr, hardcodedRole, "ID Match")
        return
    end

    -- 2. Check Group Role
    local role = plr:GetRoleInGroup(GROUP_ID)
    if table.find(STAFF_ROLES, role) then
        DisableFeaturesAndNotify(plr, role, "Group Role")
    end
end

local function OnPlayerRemoving(plr)
    local index = table.find(activeStaff, plr)
    if index then
        table.remove(activeStaff, index)
        
        -- Update Moderator List UI
        if library.remove_moderator then
            library:remove_moderator(plr.Name)
        end
        
        if #activeStaff == 0 then
            RestoreFeatures()
        end
    end
end

-- Initial Check
task.spawn(function()
    task.wait(1)
    for _, plr in ipairs(game:GetService("Players"):GetPlayers()) do
        if plr ~= game:GetService("Players").LocalPlayer then
            CheckPlayer(plr)
        end
    end
end)

-- [RESTORED LOGIC START]

-- Helper: Get Closest Player
local function GetClosestPlayer(fov_limit)
    local closest = nil
    local max_dist = fov_limit or math.huge
    local mouse_pos = uis:GetMouseLocation()

    for _, plr in pairs(players:GetPlayers()) do
        if plr ~= players.LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
            -- Team Check
            if library.flags.team_check and plr.Team == players.LocalPlayer.Team then
                continue
            end
            -- Knocked Check (Da Hood specific)
            if plr.Character:FindFirstChild("BodyEffects") then
                local ko = plr.Character.BodyEffects:FindFirstChild("K.O")
                if ko and ko.Value then continue end
            end

            local part = plr.Character:FindFirstChild(selectedPart or "Head")
            if part then
                local pos, on_screen = camera:WorldToViewportPoint(part.Position)
                if on_screen then
                    local dist = (vec2(pos.X, pos.Y) - mouse_pos).Magnitude
                    if dist < max_dist then
                        -- Wall Check
                        if library.flags.wall_check then
                            local params = RaycastParams.new()
                            params.FilterDescendantsInstances = {players.LocalPlayer.Character, camera}
                            params.FilterType = Enum.RaycastFilterType.Exclude
                            local ray = ws:Raycast(camera.CFrame.Position, part.Position - camera.CFrame.Position, params)
                            if ray and ray.Instance and not ray.Instance:IsDescendantOf(plr.Character) then
                                continue
                            end
                        end
                        
                        max_dist = dist
                        closest = plr
                    end
                end
            end
        end
    end
    return closest
end

-- Main Render Loop (Camera & FOV)
run.RenderStepped:Connect(function()
    local mouse_pos = uis:GetMouseLocation()
    
    -- Update FOV Circles
    if FOVCircle then
        FOVCircle.Position = mouse_pos
        FOVCircle.Radius = (TargetFOV or 45) * 5 
        FOVCircle.Color = FOVColor
        FOVCircle.Transparency = FOVAlpha
        FOVCircle.Visible = library.flags.toggle_fov_circle
    end
    
    if SilentFOVCircle then
        SilentFOVCircle.Position = mouse_pos
        SilentFOVCircle.Radius = (SilentTargetFOV or 45) * 5
        SilentFOVCircle.Color = SilentFOVColor
        SilentFOVCircle.Transparency = SilentFOVAlpha
        SilentFOVCircle.Visible = library.flags.toggle_fov_circle_silent
    end
    
    -- Camera Lock Logic
    if library.flags.toggle_camera_lock and IsCameraLockActive then
        CurrentTarget = GetClosestPlayer((TargetFOV or 45) * 5)
        if CurrentTarget and CurrentTarget.Character then
            local part = CurrentTarget.Character:FindFirstChild(selectedPart or "Head")
            if part then
                local targetCFrame = CFrame.new(camera.CFrame.Position, part.Position)
                local smooth = 1
                -- Da Hood specific: check for smoothness flag if it exists, else instant
                if library.flags.smoothness then smooth = library.flags.smoothness end
                
                camera.CFrame = camera.CFrame:Lerp(targetCFrame, smooth)
            end
        end
    else
        CurrentTarget = nil
    end
end)

-- Silent Aim Hook (Namecall)
local mt = getrawmetatable(game)
local old_namecall = mt.__namecall
setreadonly(mt, false)

mt.__namecall = newcclosure(function(self, ...)
    local args = {...}
    local method = getnamecallmethod()
    
    if method == "FireServer" and library.flags.toggle_silent and USE_NAMECALL_HOOK then
        -- Heuristic: Check if arguments contain Vector3 (likely mouse pos)
        local target = GetClosestPlayer((SilentTargetFOV or 45) * 5)
        if target and target.Character then
            local part = target.Character:FindFirstChild(selectedPart or "Head")
            if part then
                 -- Top-level argument scanning to replace mouse position
                 for i, v in pairs(args) do
                     if typeof(v) == "Vector3" then
                         -- Replace Vector3 arg with target position
                         args[i] = part.Position
                     end
                 end
                 return old_namecall(self, unpack(args))
            end
        end
    end
    
    return old_namecall(self, ...)
end)
setreadonly(mt, true)

-- Input Handling
uis.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    -- Check Keybind (Camera Lock)
    -- Note: Keybinds in UiLib usually handle themselves, but for 'hold' mode we might need this
    -- or the library callback handles it. Assuming library callback sets flag, but for hold mode:
    if input.UserInputType == Enum.UserInputType.MouseButton2 then -- Default
        IsCameraLockActive = true
    end
end)

uis.InputEnded:Connect(function(input, gpe)
    if gpe then return end
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        IsCameraLockActive = false
    end
end)

print("Loaded Script.txt with restored logic")

game:GetService("Players").PlayerAdded:Connect(function(plr)
    task.wait(1)
    CheckPlayer(plr)
end)

game:GetService("Players").PlayerRemoving:Connect(OnPlayerRemoving)

-- [END] Staff Detection & Notification Logic



local themes = library.themes
local lp = players.LocalPlayer
local camera = ws.CurrentCamera
local SCPESPCache = {}
local SCPViewportCache = {}
library.DesyncData = { RealCFrame = nil, RealVelocity = nil }
local ViewportScreenGui = Instance.new("ScreenGui")
ViewportScreenGui.Name = "SCPViewportESP"
ViewportScreenGui.IgnoreGuiInset = true
if gethui then
    ViewportScreenGui.Parent = gethui()
elseif game:GetService("CoreGui") then
    ViewportScreenGui.Parent = game:GetService("CoreGui")
else
    ViewportScreenGui.Parent = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")
end
local ViewportFrame = Instance.new("ViewportFrame")
ViewportFrame.Size = UDim2.new(1, 0, 1, 0)
ViewportFrame.BackgroundTransparency = 1
ViewportFrame.Ambient = Color3.new(1, 1, 1)
ViewportFrame.LightColor = Color3.new(1, 1, 1)
ViewportFrame.Parent = ViewportScreenGui
local ViewportCamera = Instance.new("Camera")
ViewportCamera.Parent = ViewportFrame
ViewportFrame.CurrentCamera = ViewportCamera

local lastSCPScan = 0
local SCPNameCache = {}
local SCPCandidateCache = {}

local function updateSCPCandidate(descendant, adding)
    if not descendant:IsA("Model") then return end
    local name = string.lower(descendant.Name)
    if string.find(name, "scp") or (name:match("^%d%d%d$") and not name:find("room") and not name:find("door")) then
        if name:find("316") then
            return
        end
        -- Explicitly allow specific SCPs that might be caught by filters (e.g. "Class" in name)
        -- Also ensure we don't accidentally include "camera", "base", or "containment" props for these SCPs
        if (name:find("066") or name:find("023") or name:find("966") or name:find("457") or name:find("999") or name:find("076") or name:find("096") or name:find("093") or name:find("087")) and not name:find("camera") and not name:find("base") and not name:find("containment") and not name:find("door") and not name:find("cam") and not name:find("room") and not name:find("cell") and not name:find("monitor") then
             if adding then
                SCPCandidateCache[descendant] = true
             else
                SCPCandidateCache[descendant] = nil
             end
             return
        end

        -- Filter out useless visuals (static props, signs, terminals, cameras, etc.)
        if name:find("sign") or name:find("terminal") or name:find("button") or name:find("door") or name:find("class") or name:find("containment") or name:find("tesla") or name:find("camera") or name:find("bowl") or name:find("cc") or name:find("pipe") or name:find("label") or name:find("screen") or name:find("monitor") or name:find("console") or name:find("glass") or name:find("window") or name:find("wall") or name:find("floor") or name:find("ceiling") or name:find("light") or name:find("lamp") or name:find("shelf") or name:find("rack") or name:find("cabinet") or name:find("box") or name:find("crate") or name:find("966") or name:find("299") or name:find("2950") or name:find("082") or name:find("180") then
            if adding then
                SCPCandidateCache[descendant] = nil -- Ensure it's removed if it was there
            end
            return
        end

        if adding then
            SCPCandidateCache[descendant] = true
        else
            SCPCandidateCache[descendant] = nil
        end
    end
end
ws.DescendantAdded:Connect(function(d) updateSCPCandidate(d, true) end)
ws.DescendantRemoving:Connect(function(d) updateSCPCandidate(d, false) end)
task.spawn(function()
    local descendants = ws:GetDescendants()
    local batchSize = 1000
    for i, d in ipairs(descendants) do
        updateSCPCandidate(d, true)
        if i % batchSize == 0 then task.wait() end
    end
end)
local oldLightingSettings = {
    Brightness = lighting.Brightness,
    ClockTime = lighting.ClockTime,
    FogEnd = lighting.FogEnd,
    GlobalShadows = lighting.GlobalShadows,
    OutdoorAmbient = lighting.OutdoorAmbient,
    Ambient = lighting.Ambient
}




local RoleColors = {
    ["Class - D"] = Color3.fromRGB(255,136,0),
    ["Security Department"] = Color3.fromRGB(128,128,128),
    ["Mobile Task Force"] = Color3.fromRGB(0,102,255),
    ["Chaos Insurgency"] = Color3.fromRGB(36,36,36),
    ["Scientific Department"] = Color3.fromRGB(255,255,255),
    ["Medical Department"] = Color3.fromRGB(173,216,230),
    ["Administrative Department"] = Color3.fromRGB(0,128,0),
    ["Intelligence Agency"] = Color3.fromRGB(255,117,117),
    ["Internal Security Department"] = Color3.fromRGB(201,33,33),
    ["Rapid Response Team"] = Color3.fromRGB(255,188,188),
}


local function createDraw(cls, props)
    local d = Drawing.new(cls)
    for k,v in pairs(props) do d[k] = v end
    return d
end

local function updateDotted(dotsTable, center, radius, color, visible, numDots, dotSize)
    if not visible then
        for _, dot in pairs(dotsTable) do dot:Remove() end
        table.clear(dotsTable)
        return
    end
    
    -- Create missing dots
    if #dotsTable < numDots then
        for i = #dotsTable + 1, numDots do
            local dot = createDraw("Circle", {
                Filled = true,
                Transparency = 1,
                Thickness = 1,
                Visible = true
            })
            table.insert(dotsTable, dot)
        end
    end
    
    -- Remove excess dots
    if #dotsTable > numDots then
        for i = numDots + 1, #dotsTable do
            dotsTable[i]:Remove()
            dotsTable[i] = nil
        end
    end
    
    -- Update positions
    for i = 1, numDots do
        local dot = dotsTable[i]
        dot.Color = color
        dot.Radius = dotSize
        
        local angle = math.rad((i - 1) / numDots * 360)
        local offsetX = math.cos(angle) * radius
        local offsetY = math.sin(angle) * radius
        dot.Position = center + Vector2.new(offsetX, offsetY)
        dot.Visible = true
    end
end

local function GetBestCamlockTarget()
    if not lp.Character then return nil, nil, nil end
    local best, bd = nil, math.huge
    for _, p in ipairs(players:GetPlayers()) do
        if p ~= lp and ValidateTarget(lp, p) then
            local part = getPartSafe(p.Character, selectedPart) or getPartSafe(p.Character, "Head")
            if part then
                local sp, on = camera:WorldToViewportPoint(part.Position)
                if on then
                    local dist = (Vector2.new(sp.X, sp.Y) - Vector2.new(camera.ViewportSize.X/2, camera.ViewportSize.Y/2)).Magnitude
                    if dist < TargetFOV * 5 and dist < bd then
                        if PerformLineOfSightCheck(p) then
                            best, bd = p, dist
                        end
                    end
                end
            end
        end
    end
    if best and best.Character then
        local tp = getPartSafe(best.Character, selectedPart) or getPartSafe(best.Character, "Head")
        if tp then
            return tp, tp.Position, best
        end
    end
    return nil, nil, nil
end

local function getPartSafe(char, name)
    if not char then return nil end
    if name == "Torso" then name = "UpperTorso" end
    local p = char:FindFirstChild(name)
    if not p then
        if name == "Neck" then return char:FindFirstChild("Head") end
        return nil 
    end
    if p:IsA("Accessory") then
        return p:FindFirstChild("Handle")
    elseif p:IsA("BasePart") then
        return p
    end
    return nil
end

local function IsFriend(p) return lp and lp:IsFriendsWith(p.UserId) end
local function RetrievePlayerTeamName(p) return p.Team and p.Team.Name or "NoTeam" end
local function ResolveFont(name)
    if type(name) ~= "string" then return Enum.Font.SourceSansBold end
    
    -- Match buckets from DrawingFontFromName exactly
    
    -- Bucket 1: Tech/Retro -> Plex (Drawing) -> RobotoMono (Roblox)
    -- This ensures visual similarity to the Drawing "Plex" font
    if name == "Plex" or name == "Minecraftia" or name == "Pixel" or name == "Arcade" then 
        return Enum.Font.RobotoMono 
    end
    
    -- Bucket 2: Monospace -> Monospace (Drawing) -> Code (Roblox)
    if name == "RobotoMono" or name == "Code" then 
        return Enum.Font.Code 
    end
    
    -- Bucket 3: System -> System (Drawing) -> Arial (Roblox)
    if name == "System" then 
        return Enum.Font.Arial 
    end
    
    -- Bucket 4: Default -> UI (Drawing) -> SourceSansBold (Roblox)
    return Enum.Font.SourceSansBold
end

local function ValidateTarget(lp, tp)
    if flags.toggle_friend_check and IsFriend(tp) then return false end
    local tch = tp.Character
    if not tch then return false end
    if flags.toggle_forcefield_check and tch:FindFirstChildOfClass("ForceField") then return false end
    local hum = tch:FindFirstChildOfClass("Humanoid")
    if not hum or (flags.toggle_death_check and hum.Health <= 0) then return false end
    if not flags.toggle_team_check then
        return true
    end
    local lt, tt = RetrievePlayerTeamName(lp), RetrievePlayerTeamName(tp)
    local hostile = {}
    if lt == "Class - D" or lt == "Chaos Insurgency" then
        hostile = {
            ["Security Department"]=true,["Mobile Task Force"]=true,
            ["Internal Security Department"]=true,["Rapid Response Team"]=true,
            ["Scientific Department"]=true,["Medical Department"]=true,
            ["Administrative Department"]=true,["Intelligence Agency"]=true,
        }
    else
        hostile = { ["Class - D"]=true, ["Chaos Insurgency"]=true }
    end
    return hostile[tt] or false
end

local LOS_PARTS = {"Head", "UpperTorso"}
local LOS_PARAMS = RaycastParams.new()
LOS_PARAMS.FilterType = Enum.RaycastFilterType.Blacklist

local function PerformLineOfSightCheck(target)
    if not flags.toggle_raycast then return true end
    local origin = getPartSafe(lp.Character, "Head")
    if not origin then return false end

    LOS_PARAMS.FilterDescendantsInstances = {lp.Character}

    local char = target
    if target:IsA("Player") then char = target.Character end
    if not char then return false end

    local checkedAny = false
    -- Expanded list to include Torso and HumanoidRootPart explicitly for better SCP/R6 detection
    local checkParts = {"Head", "UpperTorso", "Torso", "HumanoidRootPart"}
    
    for _, name in ipairs(checkParts) do
        -- Direct FindFirstChild to avoid getPartSafe's renaming logic for Torso
        local part = char:FindFirstChild(name)
        if part and part:IsA("BasePart") then
            checkedAny = true
            local ray = ws:Raycast(origin.Position, part.Position - origin.Position, LOS_PARAMS)
            if not ray or ray.Instance == part or ray.Instance.Name == "Handle" or ray.Instance:IsDescendantOf(char) then
                return true
            end
        end
    end

    if not checkedAny then
        local part = char.PrimaryPart or char:FindFirstChild("HumanoidRootPart")
        if not part then
             for _, ch in ipairs(char:GetChildren()) do
                 if ch:IsA("BasePart") then part = ch break end
             end
        end
        
        if part then
            local ray = ws:Raycast(origin.Position, part.Position - origin.Position, LOS_PARAMS)
            if not ray or ray.Instance == part or ray.Instance.Name == "Handle" or ray.Instance:IsDescendantOf(char) then
                return true
            end
        end
    end

    return false
end

local function LockCameraToTargetPlayer()
    if not lp.Character then
        CurrentTarget = nil
        return
    end

    if flags.toggle_required_weapon then
        local tool = lp.Character:FindFirstChildOfClass("Tool")
        if not tool then
            CurrentTarget = nil
            return
        end
    end

    if flags.toggle_sticky_lock and CurrentTarget then
        local ct = CurrentTarget
        local ch = ct
        if ct:IsA("Player") then ch = ct.Character end
        
        if ch then
            local hum = ch:FindFirstChildOfClass("Humanoid")
            local isAlive = true
            if hum then isAlive = hum.Health > 0 end

            if isAlive then
                local tp = getPartSafe(ch, selectedPart) or ch.PrimaryPart or ch:FindFirstChild("Head") or ch:FindFirstChild("HumanoidRootPart")
                if not tp then
                     for _, child in ipairs(ch:GetChildren()) do
                         if child:IsA("BasePart") then tp = child break end
                     end
                end

                if tp then
                    local cf = camera.CFrame
                    local predictedPos = tp.Position
                    camera.CFrame = CFrame.new(cf.Position, predictedPos)
                    return
                end
            end
        end
        CurrentTarget = nil
    end

    local best, bd = nil, math.huge
    for _, p in ipairs(players:GetPlayers()) do
        if p ~= lp and ValidateTarget(lp, p) then
            local part = getPartSafe(p.Character, selectedPart)
            if part then
                local sp, on = camera:WorldToViewportPoint(part.Position)
                if on then
                    local dist = (Vector2.new(sp.X, sp.Y) - Vector2.new(camera.ViewportSize.X/2, camera.ViewportSize.Y/2)).Magnitude
                    if dist < TargetFOV * 5 and dist < bd then
                        if PerformLineOfSightCheck(p) then
                            best, bd = p, dist
                        end
                    end
                end
            end
        end
    end

    -- Built-in SCP check (always active)
    for scpModel, _ in pairs(SCPCandidateCache) do
        if scpModel and scpModel.Parent then
            local scpName = string.lower(scpModel.Name)
            local allowed = false
            -- Allow common SCPs and their variants (049, 008, 016, 096, 173, 002, 076, 682)
            if (scpName:find("049") or scpName:find("008") or scpName:find("016") or 
               scpName:find("096") or scpName:find("173") or scpName:find("002") or
               scpName:find("076") or scpName:find("682"))
               and not scpName:find("camera") and not scpName:find("monitor") and not scpName:find("cam") and not scpName:find("door") and not scpName:find("sign") and not scpName:find("button") and not scpName:find("terminal") and not scpName:find("tesla") and not scpName:find("gate") and not scpName:find("containment") and not scpName:find("chamber") and not scpName:find("glass") then
                allowed = true
            end

            if allowed then
                    local part = getPartSafe(scpModel, selectedPart) or scpModel.PrimaryPart or scpModel:FindFirstChild("HumanoidRootPart")
                    if not part then
                        for _, ch in ipairs(scpModel:GetChildren()) do
                            if ch:IsA("BasePart") then part = ch break end
                        end
                    end

                    local hum = scpModel:FindFirstChildOfClass("Humanoid")
                    local isAlive = true
                    if hum then
                        isAlive = hum.Health > 0
                    else
                        -- No humanoid? Check if it's a static prop (anchored)
                        -- If the part we found is anchored, assume it's a prop (like a camera or sign) and not a target
                        if part and part.Anchored then
                             isAlive = false
                        end
                    end

                    if part and isAlive then
                        local sp, on = camera:WorldToViewportPoint(part.Position)
                        if on then
                            local dist = (Vector2.new(sp.X, sp.Y) - Vector2.new(camera.ViewportSize.X/2, camera.ViewportSize.Y/2)).Magnitude
                            if dist < TargetFOV * 5 and dist < bd then
                                if PerformLineOfSightCheck(scpModel) then
                                    best, bd = scpModel, dist
                                end
                            end
                        end
                    end
                end
            end
        end

    if best then
        local char = best
        if best:IsA("Player") then char = best.Character end

        local tp = getPartSafe(char, selectedPart) or char.PrimaryPart or char:FindFirstChild("Head") or char:FindFirstChild("HumanoidRootPart")
        if tp then
            local predictedPos = tp.Position

            local cf = camera.CFrame
            local targetLook = CFrame.new(cf.Position, predictedPos)
            camera.CFrame = CFrame.new(cf.Position, predictedPos)
            CurrentTarget = best
            return
        end
    end
    CurrentTarget = nil
end

local function SinkInput()
    return Enum.ContextActionResult.Sink
end



uis.InputBegan:Connect(function(input, gs)
    if input.UserInputType == Enum.UserInputType.MouseButton1 and not gs then
        leftMouseDown = true
        task.spawn(function()
            while leftMouseDown and (flags.toggle_silent or false) and (flags.toggle_auto_aim or (not flags.toggle_auto_aim and flags.keybind_silent_aim and flags.keybind_silent_aim.active)) do
                local lpchar = lp.Character
                local head = lpchar and lpchar:FindFirstChild("Head")
                if not head then
                    break
                end
                local best, bd = nil, math.huge
                local camDir = camera.CFrame.LookVector
                for _, p in ipairs(players:GetPlayers()) do
                    if p ~= lp and ValidateTarget(lp, p) and p.Character and p.Character:FindFirstChild("Humanoid") then
                        local part = getPartSafe(p.Character, selectedPart) or getPartSafe(p.Character, "Head")
                        if part then
                            local dirTo = (part.Position - head.Position).Unit
                            local ang = math.acos(math.clamp(camDir:Dot(dirTo), -1, 1))
                            local maxAng = math.rad((SilentTargetFOV or 65) / 2)
                            if ang <= maxAng then
                                local dist = (part.Position - head.Position).Magnitude
                                if dist < bd then
                                    best, bd = p, dist
                                end
                            end
                        end
                    end
                end
                if best and best.Character then
                    local th = best.Character:FindFirstChild("Head")
                    if th then
                        local origin = head.Position
                        local targetPos = th.Position
                        local canFire = true
                        local dir = (targetPos - origin).Unit
                        local dist = (targetPos - origin).Magnitude
                        local rp = RaycastParams.new()
                        rp.FilterType = Enum.RaycastFilterType.Blacklist
                        rp.FilterDescendantsInstances = {lp.Character}
                        local rr = ws:Raycast(origin, dir * dist, rp)
                        if rr and rr.Instance and rr.Instance.Parent ~= best.Character and rr.Instance.Name ~= "Handle" then
                            canFire = false
                        end
                        if canFire then
                            
                        end
                    end
                end
                task.wait(SilentRate)
            end
        end)
    end
end)
uis.InputEnded:Connect(function(input, gs)
    if input.UserInputType == Enum.UserInputType.MouseButton1 and not gs then
        leftMouseDown = false
    end
end)

local function GetBestSilentTarget()
    local lpchar = lp.Character
    local head = lpchar and lpchar:FindFirstChild("Head")
    if not head then
        return nil, nil
    end
    
    local camDir = camera.CFrame.LookVector
    local origin = head.Position
    
    local bestPart = nil
    local bestAngle = math.rad((SilentTargetFOV or 65) / 2)
    
    local scanParts = {
        "Head", "UpperTorso", "LowerTorso", "Torso", "HumanoidRootPart",
        "LeftUpperArm", "RightUpperArm", "LeftLowerArm", "RightLowerArm",
        "LeftUpperLeg", "RightUpperLeg", "LeftLowerLeg", "RightLowerLeg"
    }

    for _, p in ipairs(players:GetPlayers()) do
        if p ~= lp and ValidateTarget(lp, p) and p.Character and p.Character:FindFirstChild("Humanoid") then
            -- Scan all valid parts to find the best visible one
            for _, partName in ipairs(scanParts) do
                local part = p.Character:FindFirstChild(partName)
                if part and part:IsA("BasePart") then
                    local dirTo = (part.Position - origin).Unit
                    local ang = math.acos(math.clamp(camDir:Dot(dirTo), -1, 1))
                    
                    if ang < bestAngle then
                        -- Check visibility
                        local rp = RaycastParams.new()
                        rp.FilterType = Enum.RaycastFilterType.Blacklist
                        rp.FilterDescendantsInstances = {lp.Character, camera}
                        
                        local ray = ws:Raycast(origin, part.Position - origin, rp)
                        
                        if not ray or ray.Instance:IsDescendantOf(p.Character) then
                            bestAngle = ang
                            bestPart = part
                        end
                    end
                end
            end
        end
    end
    
    if bestPart then
        return bestPart, bestPart.Position
    end
    return nil, nil
end


local function DeepRetargetTable(payload, targetPart, targetPos)
    local replacedPart = false
    local replacedPos = false
    local function visit(tbl)
        for k, v in pairs(tbl) do
            local t = typeof(v)
            if t == "Instance" and v:IsA("BasePart") and not replacedPart then
                tbl[k] = targetPart
                replacedPart = true
            elseif (t == "Vector3" or t == "CFrame") then
                local key = typeof(k) == "string" and string.lower(k) or ""
                local looksLikePos =
                    key:find("pos") or key:find("position") or key:find("hit") or key:find("target") or key:find("to")
                if looksLikePos or (replacedPart and not replacedPos) then
                    tbl[k] = (t == "CFrame") and CFrame.new(targetPos) or targetPos
                    replacedPos = true
                end
            elseif t == "table" then
                visit(v)
            end
            if replacedPart and replacedPos then
                return
            end
        end
    end
    if typeof(payload) == "table" then
        visit(payload)
    end
    return replacedPart or replacedPos
end

do
    if USE_NAMECALL_HOOK then
        -- print("Silent Aim Hook Initialized")
        local mt = getrawmetatable(game)
        local old_namecall = mt.__namecall
        setreadonly(mt, false)

        -- Using a regular function instead of newcclosure to prevent "no closure" errors on some executors
        mt.__namecall = function(self, ...)
            local args = {...}
            local method = getnamecallmethod()
            
            -- Debug: Print ALL RemoteEvent calls to find the right one
             if tostring(method) == "FireServer" and typeof(self) == "Instance" and self:IsA("RemoteEvent") then
                print("[SilentAim Debug] Remote:", self.Name, "Args:", unpack(args))
             end

            if typeof(self) == "Instance" and tostring(method) == "FireServer" and self.Name == "RemoteEvent" and (flags.toggle_silent or false) and ((flags.toggle_auto_aim and uis:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)) or (not flags.toggle_auto_aim and flags.keybind_silent_aim and flags.keybind_silent_aim.active)) then
                if (not checkcaller or not checkcaller()) then
                    local targetPart, targetPos = GetBestSilentTarget()
                    
                    -- Debug: Print if we found a target
                    if targetPart then print("[SilentAim Debug] Target Found:", targetPart.Name) end

                    if targetPart and targetPos then
                        local replaced = false
                        
                        -- Simple argument scanning (like Camlock logic)
                        -- Instead of deep recursive table scanning, we just check top-level arguments
                        -- This avoids "smart" logic that might be breaking specific game remotes
                        for i, v in ipairs(args) do
                            if typeof(v) == "Vector3" then
                                args[i] = targetPos
                                replaced = true
                            elseif typeof(v) == "CFrame" then
                                if ws.CurrentCamera then
                                    -- Camera CFrame Angles: Look from Camera to Target
                                    args[i] = CFrame.new(ws.CurrentCamera.CFrame.Position, targetPos)
                                else
                                    args[i] = CFrame.new(targetPos)
                                end
                                replaced = true
                            elseif typeof(v) == "Instance" and v:IsA("BasePart") then
                                local char = v.Parent
                                if char and (char:FindFirstChild("Humanoid") or char.Parent:FindFirstChild("Humanoid")) then
                                    args[i] = targetPart
                                    replaced = true
                                end
                            end
                        end
                        
                        if replaced then
                             print("[SilentAim Debug] Arguments replaced for", self.Name)
                             if setnamecallmethod then setnamecallmethod(method) end
                             return old_namecall(self, unpack(args))
                        end
                    end
                end
            end
            
            if setnamecallmethod then setnamecallmethod(method) end
            return old_namecall(self, ...)
        end

        setreadonly(mt, true)
    end
end

local CameraSilentAimHooked = false
local __silentIndexBusy = false
local function EnableCameraSilentAim()
    if CameraSilentAimHooked then return true end
    if hookmetamethod then
        local mouseRef = lp and lp:GetMouse()
        local original
        local hookFunc = function(self, key)
            if typeof(self) == "Instance" then
               if key == "CFrame" and library.flags["desync_server"] and library.DesyncData and library.DesyncData.RealCFrame and not checkcaller() then
                    local char = lp.Character
                    if char and self == char:FindFirstChild("HumanoidRootPart") then
                         local callingScript = getcallingscript()
                         if callingScript and tostring(callingScript) == "CameraModule" then
                             return library.DesyncData.RealCFrame
                         end
                    end
               end
            end
            if typeof(self) == "Instance" and not __silentIndexBusy then
                if (flags.toggle_silent_camlock or false)
                    and self == ws.CurrentCamera
                    and (key == "CFrame" or key == "Focus")
                    and ((flags.keybind_camera_lock and flags.keybind_camera_lock.active) or (flags.toggle_auto_aim and uis:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) and flags.keybind_camera_lock and flags.keybind_camera_lock.key == Enum.UserInputType.MouseButton2) or false)
                then
                    __silentIndexBusy = true
                    local targetPart, targetPos = GetBestCamlockTarget()
                    __silentIndexBusy = false
                    if targetPart and targetPos then
                        local base = original(self, key)
                        if typeof(base) == "CFrame" then
                            return CFrame.new(base.Position, targetPos)
                        end
                        return base
                    end
                elseif (flags.toggle_silent or false) and ((flags.toggle_auto_aim and uis:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)) or (not flags.toggle_auto_aim and flags.keybind_silent_aim and flags.keybind_silent_aim.active)) and mouseRef and self == mouseRef and (key == "Hit" or key == "Target") then
                    __silentIndexBusy = true
                    local targetPart, targetPos = GetBestSilentTarget()
                    __silentIndexBusy = false
                    if targetPart and targetPos then
                        if key == "Hit" then
                            return CFrame.new(targetPos)
                        else
                            return targetPart
                        end
                    end
                end
            end
            return original(self, key)
        end
        
        if newcclosure then
            hookFunc = newcclosure(hookFunc)
        end
        
        original = hookmetamethod(game, "__index", hookFunc)
        CameraSilentAimHooked = true
        return true
    end
    return false
end

EnableCameraSilentAim()

local occlusionRects = {}
local function isOccluded(pos)
    if not library or not library.menu_open then return false end
    for _, rect in ipairs(occlusionRects) do
        if pos.X >= rect.x and pos.X <= rect.x + rect.w and
           pos.Y >= rect.y and pos.Y <= rect.y + rect.h then
            return true
        end
    end
    return false
end


if coregui:FindFirstChild("BronxESPHolder") then
    coregui.BronxESPHolder:Destroy()
end

local BronxESPHolder = Instance.new("ScreenGui")
BronxESPHolder.Name = "BronxESPHolder"
BronxESPHolder.Parent = coregui
BronxESPHolder.ResetOnSpawn = false

local function CreateBronxElement(type, props)
    local inst = Instance.new(type)
    for k,v in pairs(props) do
        if k ~= "Parent" then inst[k] = v end
    end
    if props.Parent then inst.Parent = props.Parent end
    return inst
end

local function AddOutline(frame, thickness)
    local t = thickness or 1
    CreateBronxElement("Frame", {Parent = frame, BorderSizePixel = 0, BackgroundColor3 = Color3.new(0,0,0), Position = UDim2.new(0, -t, 0, -t), Size = UDim2.new(1, t*2, 0, t), ZIndex = frame.ZIndex - 1})
    CreateBronxElement("Frame", {Parent = frame, BorderSizePixel = 0, BackgroundColor3 = Color3.new(0,0,0), Position = UDim2.new(0, -t, 1, 0), Size = UDim2.new(1, t*2, 0, t), ZIndex = frame.ZIndex - 1})
    CreateBronxElement("Frame", {Parent = frame, BorderSizePixel = 0, BackgroundColor3 = Color3.new(0,0,0), Position = UDim2.new(0, -t, 0, 0), Size = UDim2.new(0, t, 1, 0), ZIndex = frame.ZIndex - 1})
    CreateBronxElement("Frame", {Parent = frame, BorderSizePixel = 0, BackgroundColor3 = Color3.new(0,0,0), Position = UDim2.new(1, 0, 0, 0), Size = UDim2.new(0, t, 1, 0), ZIndex = frame.ZIndex - 1})
end

local Fonts = {}
task.spawn(function()
    local function RegisterFont(Name, Weight, Style, Asset)
        local dir = (library and library.directory) or "TraeScript"
        if not isfolder(dir) then makefolder(dir) end
        if not isfolder(dir.."/assets") then makefolder(dir.."/assets") end
        if not isfolder(dir.."/fonts") then makefolder(dir.."/fonts") end
        
        if isfile(dir.."/assets/"..Asset.Id) then
            delfile(dir.."/assets/"..Asset.Id)
        end

        writefile(dir.."/assets/"..Asset.Id, Asset.Font)

        local Data = {
            name = Name,
            faces = {
                {
                    Name = "Normal",
                    weight = Weight,
                    style = Style,
                    assetId = getcustomasset(dir.."/assets/"..Asset.Id),
                },
            },
        }

        writefile(dir.."/fonts/"..Name .. ".font", http_service:JSONEncode(Data))

        return getcustomasset(dir.."/fonts/"..Name .. ".font");
    end
    
    pcall(function()
        local Tahoma = RegisterFont("Tahoma", 400, "Normal", {
            Id = "Tahoma.ttf",
            Font = game:HttpGet("https://github.com/KingVonOBlockJoyce/OctoHook-UI/raw/refs/heads/main/fs-tahoma-8px%20(3).ttf"),
        })
        Fonts["Plex"] = Font.new(Tahoma, Enum.FontWeight.Regular, Enum.FontStyle.Normal)
    end)

    pcall(function()
        local Minecraftia = RegisterFont("Minecraftia", 400, "Normal", {
            Id = "Minecraftia.ttf",
            Font = game:HttpGet("https://github.com/i77lhm/storage/raw/refs/heads/main/fonts/Minecraftia-Regular.ttf"),
        }) 
        Fonts["Minecraft"] = Font.new(Minecraftia, Enum.FontWeight.Regular, Enum.FontStyle.Normal)
    end)
end)

local BronxESPCache = {}

local ESPCache = {}
local function setupESPCache(p)
    -- Bronx Visuals Setup
    local ScreenGui = BronxESPHolder
    BronxESPCache[p] = {}
    local b = BronxESPCache[p]
    
    b.Box = CreateBronxElement("Frame", {Parent = ScreenGui, BackgroundColor3 = Color3.fromRGB(0, 0, 0), BackgroundTransparency = 0.75, BorderSizePixel = 0, Visible = false})
    b.Gradient1 = CreateBronxElement("UIGradient", {Parent = b.Box, Enabled = false})
    b.Outline = CreateBronxElement("UIStroke", {Parent = b.Box, Enabled = false, Transparency = 0, Color = Color3.fromRGB(255, 255, 255), LineJoinMode = Enum.LineJoinMode.Miter})
    b.Gradient2 = CreateBronxElement("UIGradient", {Parent = b.Outline, Enabled = false})
    
    b.Healthbar = CreateBronxElement("Frame", {Parent = ScreenGui, BackgroundColor3 = Color3.fromRGB(255, 255, 255), BackgroundTransparency = 0, Visible = false})
    b.BehindHealthbar = CreateBronxElement("Frame", {BorderColor3 = Color3.fromRGB(0, 0, 0), Parent = ScreenGui, ZIndex = -1, BackgroundColor3 = Color3.fromRGB(0, 0, 0), BackgroundTransparency = 0, Visible = false})
    b.HealthbarGradient = CreateBronxElement("UIGradient", {Parent = b.Healthbar, Enabled = false, Rotation = -90})
    
    b.Chams = CreateBronxElement("Highlight", {Parent = ScreenGui, FillTransparency = 1, OutlineTransparency = 0, OutlineColor = Color3.fromRGB(119, 120, 255), DepthMode = "AlwaysOnTop", Enabled = false})
    
    b.Name = CreateBronxElement("TextLabel", {Parent = ScreenGui, BackgroundTransparency = 1, TextSize = 13, TextStrokeTransparency = 0, TextColor3 = Color3.new(1,1,1), Visible = false, Font = Enum.Font.RobotoMono, TextXAlignment = Enum.TextXAlignment.Center})
    b.Distance = CreateBronxElement("TextLabel", {Parent = ScreenGui, BackgroundTransparency = 1, TextSize = 12, TextStrokeTransparency = 0, TextColor3 = Color3.new(1,1,1), Visible = false, Font = Enum.Font.RobotoMono, TextXAlignment = Enum.TextXAlignment.Center})
    b.Weapon = CreateBronxElement("TextLabel", {Parent = ScreenGui, BackgroundTransparency = 1, TextSize = 12, TextStrokeTransparency = 0, TextColor3 = Color3.new(1,1,1), Visible = false, Font = Enum.Font.RobotoMono, TextXAlignment = Enum.TextXAlignment.Center})
    b.HealthText = CreateBronxElement("TextLabel", {Parent = ScreenGui, BackgroundTransparency = 1, TextSize = 12, TextStrokeTransparency = 0, TextColor3 = Color3.new(0,1,0), Visible = false, Font = Enum.Font.RobotoMono, TextXAlignment = Enum.TextXAlignment.Center})
    
    -- Corner Boxes
    b.LeftTop = CreateBronxElement("Frame", {Parent = ScreenGui, BackgroundColor3 = Color3.new(1,1,1), Position = UDim2.new(0, 0, 0, 0), BorderSizePixel = 0, Visible = false})
    AddOutline(b.LeftTop, 1)
    b.LeftSide = CreateBronxElement("Frame", {Parent = ScreenGui, BackgroundColor3 = Color3.new(1,1,1), Position = UDim2.new(0, 0, 0, 0), BorderSizePixel = 0, Visible = false})
    AddOutline(b.LeftSide, 1)
    b.RightTop = CreateBronxElement("Frame", {Parent = ScreenGui, BackgroundColor3 = Color3.new(1,1,1), Position = UDim2.new(0, 0, 0, 0), BorderSizePixel = 0, Visible = false})
    AddOutline(b.RightTop, 1)
    b.RightSide = CreateBronxElement("Frame", {Parent = ScreenGui, BackgroundColor3 = Color3.new(1,1,1), Position = UDim2.new(0, 0, 0, 0), BorderSizePixel = 0, Visible = false})
    AddOutline(b.RightSide, 1)
    b.BottomSide = CreateBronxElement("Frame", {Parent = ScreenGui, BackgroundColor3 = Color3.new(1,1,1), Position = UDim2.new(0, 0, 0, 0), BorderSizePixel = 0, Visible = false})
    AddOutline(b.BottomSide, 1)
    b.BottomDown = CreateBronxElement("Frame", {Parent = ScreenGui, BackgroundColor3 = Color3.new(1,1,1), Position = UDim2.new(0, 0, 0, 0), BorderSizePixel = 0, Visible = false})
    AddOutline(b.BottomDown, 1)
    b.BottomRightSide = CreateBronxElement("Frame", {Parent = ScreenGui, BackgroundColor3 = Color3.new(1,1,1), Position = UDim2.new(0, 0, 0, 0), BorderSizePixel = 0, Visible = false})
    AddOutline(b.BottomRightSide, 1)
    b.BottomRightDown = CreateBronxElement("Frame", {Parent = ScreenGui, BackgroundColor3 = Color3.new(1,1,1), Position = UDim2.new(0, 0, 0, 0), BorderSizePixel = 0, Visible = false})
    AddOutline(b.BottomRightDown, 1)

    -- Animation State
    b.RotationAngle = 0
    b.LastTick = tick()

    -- End Bronx Visuals Setup

    ESPCache[p] = {
        isVisible = false,
        lines = {},
        lines_outline = {},
        box_lines = {},
        box_outline_lines = {},
        corner_lines = {},
        corner_outline_lines = {},
        filled_box = createDraw("Square", {Visible = false, Filled = true, Color = Color3.fromRGB(255,255,255), Transparency = 0.8}),
        name_text = createDraw("Text", {Visible = false, Color = Color3.new(1,1,1), Outline = true, OutlineColor = Color3.new(0,0,0), Size = 12, Font = Drawing.Fonts.UI, Center = false}),
        dist_text = createDraw("Text", {Visible = false, Color = Color3.new(1,1,1), Outline = true, OutlineColor = Color3.new(0,0,0), Size = 12, Font = Drawing.Fonts.UI, Center = false}),
        health_text = createDraw("Text", {Visible = false, Color = Color3.new(1,1,1), Outline = true, OutlineColor = Color3.new(0,0,0), Size = 12, Font = Drawing.Fonts.UI, Center = false}),
        health_back_outline = createDraw("Line", {Visible = false, Color = Color3.new(0,0,0), Thickness = 5}),
        health_back = createDraw("Line", {Visible = false, Color = Color3.fromRGB(30,30,30), Thickness = 3}),
        health_front_outline = createDraw("Line", {Visible = false, Color = Color3.new(0,0,0), Thickness = 5}),
        health_front = createDraw("Line", {Visible = false, Color = Color3.fromRGB(0,255,0), Thickness = 3}),
        health_ratio = 1,
        box_prev_minX = nil,
        box_prev_minY = nil,
        box_prev_maxX = nil,
        box_prev_maxY = nil,
        box_prev_valid = false
    }
    for i = 1, 4 do
        table.insert(ESPCache[p].box_outline_lines, createDraw("Line", {Visible = false, Color = Color3.new(0,0,0), Thickness = 3}))
        table.insert(ESPCache[p].box_lines, createDraw("Line", {Visible = false, Color = Color3.fromRGB(255,255,255), Thickness = 1}))
    end
    for i = 1, 8 do
        table.insert(ESPCache[p].corner_outline_lines, createDraw("Line", {Visible = false, Color = Color3.new(0,0,0), Thickness = 3}))
        table.insert(ESPCache[p].corner_lines, createDraw("Line", {Visible = false, Color = Color3.fromRGB(255,255,255), Thickness = 2}))
    end
end

local PlayerChamsCache = {}
players.PlayerAdded:Connect(setupESPCache)
players.PlayerRemoving:Connect(function(p)
    if BronxESPCache[p] then
        for _, v in pairs(BronxESPCache[p]) do
            if typeof(v) == "Instance" then v:Destroy() end
        end
        BronxESPCache[p] = nil
    end
    if ESPCache[p] then
        for _, line in ipairs(ESPCache[p].box_lines) do line:Remove() end
        for _, line in ipairs(ESPCache[p].box_outline_lines) do line:Remove() end
        for _, line in ipairs(ESPCache[p].corner_lines) do line:Remove() end
        for _, line in ipairs(ESPCache[p].corner_outline_lines) do line:Remove() end
        if ESPCache[p].filled_box then ESPCache[p].filled_box:Remove() end
        if ESPCache[p].name_text then ESPCache[p].name_text:Remove() end
        if ESPCache[p].dist_text then ESPCache[p].dist_text:Remove() end
        if ESPCache[p].health_text then ESPCache[p].health_text:Remove() end
        if ESPCache[p].health_back_outline then ESPCache[p].health_back_outline:Remove() end
        if ESPCache[p].health_back then ESPCache[p].health_back:Remove() end
        if ESPCache[p].health_front_outline then ESPCache[p].health_front_outline:Remove() end
        if ESPCache[p].health_front then ESPCache[p].health_front:Remove() end
        ESPCache[p] = nil
    end
    if PlayerChamsCache[p] then
        PlayerChamsCache[p]:Destroy()
        PlayerChamsCache[p] = nil
    end
end)
for _, p in ipairs(players:GetPlayers()) do
    setupESPCache(p)
end

local function hidePlayerESP(p)
    local c = ESPCache[p]
    if not c or not c.isVisible then return end
    c.isVisible = false
    
    for _, l in ipairs(c.box_lines) do l.Visible = false end
    for _, l in ipairs(c.box_outline_lines) do l.Visible = false end
    for _, l in ipairs(c.corner_lines) do l.Visible = false end
    for _, l in ipairs(c.corner_outline_lines) do l.Visible = false end
    c.filled_box.Visible = false
    c.name_text.Visible = false
    c.dist_text.Visible = false
    c.health_text.Visible = false
    if c.health_back_outline then c.health_back_outline.Visible = false end
    c.health_back.Visible = false
    if c.health_front_outline then c.health_front_outline.Visible = false end
    c.health_front.Visible = false
    c.box_prev_valid = false
end

local function characterCenterOnScreen(char)
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if not root then return false end
    local v2, on = camera:WorldToViewportPoint(root.Position)
    return on and v2.Z > 0
end

local function DrawingFontFromName(name)
    -- Bucket 1: Tech/Retro -> Plex
    if name == "Plex" or name == "Minecraftia" or name == "Minecraft" or name == "Pixel" or name == "Arcade" then 
        return Drawing.Fonts.Plex 
    end
    -- Bucket 2: Monospace -> Monospace
    if name == "RobotoMono" or name == "Code" then 
        return Drawing.Fonts.Monospace 
    end
    -- Bucket 3: System -> System
    if name == "System" then 
        return Drawing.Fonts.System 
    end
    -- Bucket 4: Default -> UI (includes Tahoma)
    return Drawing.Fonts.UI
end
local function computeAABB(character)
    if not character then return nil end
    local minX, minY = math.huge, math.huge
    local maxX, maxY = -math.huge, -math.huge
    local any = false
    
    local cf, size = character:GetBoundingBox()
    if not cf or not size then return nil end
    local hx, hy, hz = size.X/2, size.Y/2, size.Z/2
    local pts = {
        cf:PointToWorldSpace(Vector3.new(-hx,-hy,-hz)),
        cf:PointToWorldSpace(Vector3.new(hx,-hy,-hz)),
        cf:PointToWorldSpace(Vector3.new(-hx,hy,-hz)),
        cf:PointToWorldSpace(Vector3.new(hx,hy,-hz)),
        cf:PointToWorldSpace(Vector3.new(-hx,-hy,hz)),
        cf:PointToWorldSpace(Vector3.new(hx,-hy,hz)),
        cf:PointToWorldSpace(Vector3.new(-hx,hy,hz)),
        cf:PointToWorldSpace(Vector3.new(hx,hy,hz)),
    }
    for i = 1, #pts do
        local v2, on = camera:WorldToViewportPoint(pts[i])
        if on then
            any = true
            if v2.X < minX then minX = v2.X end
            if v2.Y < minY then minY = v2.Y end
            if v2.X > maxX then maxX = v2.X end
            if v2.Y > maxY then maxY = v2.Y end
        end
    end
    
    if not any then return nil end
    if minX == math.huge or minY == math.huge or maxX == -math.huge or maxY == -math.huge then return nil end
    return minX, minY, maxX, maxY
end

local function validateBox(minX, minY, maxX, maxY)
    if not (minX and minY and maxX and maxY) then return false end
    local w, h = maxX - minX, maxY - minY
    if w <= 2 or h <= 2 then return false end
    local vw, vh = camera.ViewportSize.X, camera.ViewportSize.Y
    if w > vw * 1.5 or h > vh * 1.5 then return false end
    return true
end

local function clampBox(minX, minY, maxX, maxY)
    local vw, vh = camera.ViewportSize.X, camera.ViewportSize.Y
    minX = math.clamp(minX, 0, vw)
    maxX = math.clamp(maxX, 0, vw)
    minY = math.clamp(minY, 0, vh)
    maxY = math.clamp(maxY, 0, vh)
    return minX, minY, maxX, maxY
end


local currentHighlight = nil
local function setHighlight(tp)
    if currentHighlight then currentHighlight:Destroy() end
    if not tp or not tp.Character then return end
    local hl = Instance.new("Highlight")
    hl.Adornee = tp.Character
    hl.FillColor = Color3.new(0,0,0)
    hl.OutlineColor = Color3.fromRGB(255,255,255)
    hl.FillTransparency = 0.6
    hl.OutlineTransparency = 0
    hl.Parent = tp.Character
    currentHighlight = hl
end
local function clearHighlight()
    if currentHighlight then
        currentHighlight:Destroy()
        currentHighlight = nil
    end
end




 


local function worldToViewportPoint(pos)
    local screen_pos, on_screen = camera:WorldToViewportPoint(pos)
    return Vector2.new(screen_pos.X, screen_pos.Y), on_screen
end




local lastEspUpdate = 0
local espUpdateInterval = 1/30
local lastTextUpdate = 0
local textUpdateInterval = 1/15
local wasLocked = false


local function HideBronxESP(p)
    local b = BronxESPCache[p]
    if not b then return end
    if b.Box then b.Box.Visible = false end
    if b.Gradient1 then b.Gradient1.Enabled = false end
    if b.Outline then b.Outline.Enabled = false end
    if b.Gradient2 then b.Gradient2.Enabled = false end
    if b.Healthbar then b.Healthbar.Visible = false end
    if b.BehindHealthbar then b.BehindHealthbar.Visible = false end
    if b.HealthbarGradient then b.HealthbarGradient.Enabled = false end
    if b.Chams then b.Chams.Enabled = false end
    if b.Name then b.Name.Visible = false end
    if b.Distance then b.Distance.Visible = false end
    if b.Weapon then b.Weapon.Visible = false end
    if b.HealthText then b.HealthText.Visible = false end
    if b.LeftTop then b.LeftTop.Visible = false end
    if b.LeftSide then b.LeftSide.Visible = false end
    if b.RightTop then b.RightTop.Visible = false end
    if b.RightSide then b.RightSide.Visible = false end
    if b.BottomSide then b.BottomSide.Visible = false end
    if b.BottomDown then b.BottomDown.Visible = false end
    if b.BottomRightSide then b.BottomRightSide.Visible = false end
    if b.BottomRightDown then b.BottomRightDown.Visible = false end
end

local function getFlagColor(flag, default)
    if type(flag) == "table" and flag.Color then return flag.Color end
    if typeof(flag) == "Color3" then return flag end
    return default
end

local function UpdateBronxESP(p)
    if not flags.esp_enabled_dummy then 
        HideBronxESP(p)
        return 
    end

    local b = BronxESPCache[p]
    if not b then return end
    
    local char = p.Character
    if not char then 
        HideBronxESP(p)
        return 
    end
    
    local root = char:FindFirstChild("HumanoidRootPart")
    local hum = char:FindFirstChild("Humanoid")
    
    if not root or not hum or hum.Health <= 0 then
        HideBronxESP(p)
        return
    end

    local pos, onScreen = camera:WorldToScreenPoint(root.Position)
    local dist = (camera.CFrame.Position - root.Position).Magnitude
    local maxDist = flags.settings_max_dist_dummy or 1000

    if not onScreen or dist > maxDist then
        HideBronxESP(p)
        return
    end

    local teamColorOverride = nil
    if flags.esp_self_dummy then
        local teamName = RetrievePlayerTeamName(p)
        teamColorOverride = RoleColors[teamName]
    end

    local function getColor(flag, default)
        if teamColorOverride then return teamColorOverride end
        return getFlagColor(flag, default)
    end

    local size = root.Size.Y
    local scaleFactor = (size * camera.ViewportSize.Y) / (pos.Z * 2)
    local w, h = 3 * scaleFactor, 4.5 * scaleFactor
    
    -- Boxes
    local showBox = flags.esp_box_dummy
    local showCorner = flags.esp_box_corner_dummy
    local showFilled = flags.esp_fill_dummy
    local animate = flags.esp_box_animate
    
    if animate then
        -- Smooth continuous rotation based on time
        local rotationSpeed = 45 -- Degrees per second
        local currentRotation = (os.clock() * rotationSpeed) % 360
        
        b.Gradient1.Rotation = currentRotation
        b.Gradient2.Rotation = currentRotation
    else
        b.Gradient1.Rotation = -45
        b.Gradient2.Rotation = -45
    end
    
    if showBox or showFilled then
        b.Box.Visible = true
        b.Box.Position = UDim2.new(0, pos.X - w / 2, 0, pos.Y - h / 2)
        b.Box.Size = UDim2.new(0, w, 0, h)
        
        if showFilled then
            local c1 = getColor(flags.esp_fill_c1, Color3.new(1,1,1))
            local c2 = getColor(flags.esp_fill_c2, c1)
            
            b.Box.BackgroundTransparency = 0.5
            b.Gradient1.Enabled = true
            b.Gradient1.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, c1),
                ColorSequenceKeypoint.new(1, c2)
            }
            b.Box.BackgroundColor3 = Color3.new(1,1,1)
        else
            b.Box.BackgroundTransparency = 1
            b.Gradient1.Enabled = false
        end
        
        -- Logic adapted from bronx.txt for Corner vs Bounding Boxes
        local c1 = showCorner and getColor(flags.esp_box_corner_c1, Color3.new(1,1,1)) or getColor(flags.esp_box_c1, Color3.new(1,1,1))
        
        -- Disable UIStroke/Gradient as we are using manual segments
        b.Outline.Enabled = false
        b.Gradient2.Enabled = false

        if showCorner then
            -- Corner Boxes (8 segments)
            b.LeftTop.Visible = true; b.LeftTop.Position = UDim2.new(0, pos.X - w / 2, 0, pos.Y - h / 2); b.LeftTop.Size = UDim2.new(0, w / 5, 0, 1)
            b.LeftSide.Visible = true; b.LeftSide.Position = UDim2.new(0, pos.X - w / 2, 0, pos.Y - h / 2); b.LeftSide.Size = UDim2.new(0, 1, 0, h / 5)
            
            b.BottomSide.Visible = true; b.BottomSide.Position = UDim2.new(0, pos.X - w / 2, 0, pos.Y + h / 2); b.BottomSide.Size = UDim2.new(0, 1, 0, h / 5); b.BottomSide.AnchorPoint = Vector2.new(0, 1)
            b.BottomDown.Visible = true; b.BottomDown.Position = UDim2.new(0, pos.X - w / 2, 0, pos.Y + h / 2); b.BottomDown.Size = UDim2.new(0, w / 5, 0, 1); b.BottomDown.AnchorPoint = Vector2.new(0, 1)
            
            b.RightTop.Visible = true; b.RightTop.Position = UDim2.new(0, pos.X + w / 2, 0, pos.Y - h / 2); b.RightTop.Size = UDim2.new(0, w / 5, 0, 1); b.RightTop.AnchorPoint = Vector2.new(1, 0)
            b.RightSide.Visible = true; b.RightSide.Position = UDim2.new(0, pos.X + w / 2 - 1, 0, pos.Y - h / 2); b.RightSide.Size = UDim2.new(0, 1, 0, h / 5); b.RightSide.AnchorPoint = Vector2.new(0, 0)
            
            b.BottomRightSide.Visible = true; b.BottomRightSide.Position = UDim2.new(0, pos.X + w / 2, 0, pos.Y + h / 2); b.BottomRightSide.Size = UDim2.new(0, 1, 0, h / 5); b.BottomRightSide.AnchorPoint = Vector2.new(1, 1)
            b.BottomRightDown.Visible = true; b.BottomRightDown.Position = UDim2.new(0, pos.X + w / 2, 0, pos.Y + h / 2); b.BottomRightDown.Size = UDim2.new(0, w / 5, 0, 1); b.BottomRightDown.AnchorPoint = Vector2.new(1, 1)
        elseif showBox then
            -- Full Bounding Boxes (4 segments)
            b.LeftTop.Visible = true; b.LeftTop.Position = UDim2.new(0, pos.X - w / 2, 0, pos.Y - h / 2); b.LeftTop.Size = UDim2.new(0, w, 0, 1)
            b.LeftSide.Visible = true; b.LeftSide.Position = UDim2.new(0, pos.X - w / 2, 0, pos.Y - h / 2); b.LeftSide.Size = UDim2.new(0, 1, 0, h)
            
            b.BottomSide.Visible = true; b.BottomSide.Position = UDim2.new(0, pos.X - w / 2, 0, pos.Y + h / 2); b.BottomSide.Size = UDim2.new(0, w, 0, 1); b.BottomSide.AnchorPoint = Vector2.new(0, 1)
            b.RightSide.Visible = true; b.RightSide.Position = UDim2.new(0, pos.X + w / 2 - 1, 0, pos.Y - h / 2); b.RightSide.Size = UDim2.new(0, 1, 0, h); b.RightSide.AnchorPoint = Vector2.new(0, 0)
            
            -- Hide unused corner segments
            b.BottomDown.Visible = false
            b.RightTop.Visible = false
            b.BottomRightSide.Visible = false
            b.BottomRightDown.Visible = false
        else
            -- Hide all
            b.LeftTop.Visible = false; b.LeftSide.Visible = false; b.BottomSide.Visible = false; b.BottomDown.Visible = false;
            b.RightTop.Visible = false; b.RightSide.Visible = false; b.BottomRightSide.Visible = false; b.BottomRightDown.Visible = false;
        end

        if showCorner or showBox then
             -- Color assignment
            b.LeftTop.BackgroundColor3 = c1
            b.LeftSide.BackgroundColor3 = c1
            b.BottomSide.BackgroundColor3 = c1
            b.BottomDown.BackgroundColor3 = c1
            b.RightTop.BackgroundColor3 = c1
            b.RightSide.BackgroundColor3 = c1
            b.BottomRightSide.BackgroundColor3 = c1
            b.BottomRightDown.BackgroundColor3 = c1
        end
    else
        b.Box.Visible = false
        b.Outline.Enabled = false
        b.Gradient1.Enabled = false
        b.Gradient2.Enabled = false
        b.LeftTop.Visible = false; b.LeftSide.Visible = false; b.BottomSide.Visible = false; b.BottomDown.Visible = false;
        b.RightTop.Visible = false; b.RightSide.Visible = false; b.BottomRightSide.Visible = false; b.BottomRightDown.Visible = false;
    end
    
    -- Healthbar
    if flags.esp_health_bar_dummy then
        local health = math.clamp(hum.Health, 0, hum.MaxHealth) / hum.MaxHealth
        b.Healthbar.Visible = true
        b.BehindHealthbar.Visible = true
        
        b.Healthbar.Position = UDim2.new(0, pos.X - w / 2 - 5, 0, pos.Y - h / 2 + h * (1 - health))
        b.Healthbar.Size = UDim2.new(0, 2, 0, h * health)
        
        b.BehindHealthbar.Position = UDim2.new(0, pos.X - w / 2 - 5, 0, pos.Y - h / 2)
        b.BehindHealthbar.Size = UDim2.new(0, 2, 0, h)
        
        local c1 = getColor(flags.esp_health_bar_c1, Color3.new(0,1,0))
        local c2 = getColor(flags.esp_health_bar_c2, Color3.new(1,0,0))
        
        if flags.esp_health_gradient and not teamColorOverride then
            b.HealthbarGradient.Enabled = true
            b.HealthbarGradient.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, c1),
                ColorSequenceKeypoint.new(1, c2)
            }
            b.HealthbarGradient.Offset = Vector2.new(0, health - 1)
            b.Healthbar.BackgroundColor3 = Color3.new(1,1,1)
        else
            b.HealthbarGradient.Enabled = false
            b.Healthbar.BackgroundColor3 = c1
        end
    else
        b.Healthbar.Visible = false
        b.BehindHealthbar.Visible = false
    end
    
    -- Chams
    if flags.esp_chams_dummy then
        b.Chams.Enabled = true
        b.Chams.Adornee = char
        b.Chams.FillColor = getColor(flags.esp_chams_c1, Color3.new(1,0,0))
        b.Chams.OutlineColor = getColor(flags.esp_chams_c2, Color3.new(1,1,1))
        
        if flags.esp_chams_thermal then
            local breathe = math.abs(math.sin(tick() * 2))
            b.Chams.FillTransparency = 0.5 * breathe
            b.Chams.OutlineTransparency = 0.5 * breathe -- Apply breathing to outline too for full effect
        else
            b.Chams.FillTransparency = 0.5
            b.Chams.OutlineTransparency = 0
        end
    else
        b.Chams.Enabled = false
    end
    
    -- Text Logic
    local fontSize = tonumber(flags.esp_font_size_dummy) or 10
    if fontSize < 8 then fontSize = 8 end -- Safety clamp
    
    local selectedFont = flags.settings_font_dummy or "Minecraft"
    local fontFace = Fonts[selectedFont]

    local function applyTextStyle(obj)
        obj.TextSize = fontSize
        if fontFace then
            obj.FontFace = fontFace
        else
            obj.Font = Enum.Font.RobotoMono
        end
    end
    
    -- Name
    if flags.esp_name_dummy then
        b.Name.Visible = true
        b.Name.Text = p.DisplayName or p.Name
        applyTextStyle(b.Name)
        b.Name.AnchorPoint = Vector2.new(0.5, 1)
        b.Name.Size = UDim2.new(0, 200, 0, fontSize + 4)
        b.Name.Position = UDim2.new(0, pos.X, 0, pos.Y - h / 2 - 9)
        b.Name.TextColor3 = getColor(flags.esp_name_c1, Color3.new(1,1,1))
    else
        b.Name.Visible = false
    end

    local weaponVisible = false
    local textOffset = 7

    -- Weapon
    if flags.esp_weapon_dummy then
        local weapon = "None"
        local tool = char:FindFirstChildWhichIsA("Tool")
        if tool then weapon = tool.Name end
        
        b.Weapon.Visible = true
        weaponVisible = true
        b.Weapon.Text = weapon
        applyTextStyle(b.Weapon)
        b.Weapon.AnchorPoint = Vector2.new(0.5, 0)
        b.Weapon.Size = UDim2.new(0, 200, 0, fontSize + 4)
        b.Weapon.Position = UDim2.new(0, pos.X, 0, pos.Y + h / 2 + textOffset)
        b.Weapon.TextColor3 = getColor(flags.esp_weapon_c1, Color3.new(1,1,1))
    else
        b.Weapon.Visible = false
    end

    -- Distance
    if flags.esp_distance_dummy then
        b.Distance.Visible = true
        b.Distance.Text = math.floor(dist) .. " studs"
        applyTextStyle(b.Distance)
        b.Distance.AnchorPoint = Vector2.new(0.5, 0)
        b.Distance.Size = UDim2.new(0, 200, 0, fontSize + 4)
        
        local currentDistOffset = textOffset
        if weaponVisible then
            currentDistOffset = currentDistOffset + fontSize + 2
        end

        b.Distance.Position = UDim2.new(0, pos.X, 0, pos.Y + h / 2 + currentDistOffset) 
        b.Distance.TextColor3 = getColor(flags.esp_distance_c1, Color3.new(1,1,1))
    else
        b.Distance.Visible = false
    end
    
    -- Health Text
    if flags.esp_health_num_dummy then
        local health = math.clamp(hum.Health, 0, hum.MaxHealth)
        b.HealthText.Visible = true
        b.HealthText.Text = tostring(math.floor(health))
        applyTextStyle(b.HealthText)
        b.HealthText.AnchorPoint = Vector2.new(0.5, 0.5)
        b.HealthText.Size = UDim2.new(0, 50, 0, fontSize + 4)
        b.HealthText.Position = UDim2.new(0, pos.X - w / 2 - 18, 0, pos.Y - h / 2 + h * (1 - (health/hum.MaxHealth)) + 3)
        b.HealthText.TextXAlignment = Enum.TextXAlignment.Center
        
        if flags.esp_health_dynamic and not teamColorOverride then
            local healthRatio = health / hum.MaxHealth
            b.HealthText.TextColor3 = Color3.fromHSV(healthRatio * 0.3, 1, 1)
        else
            b.HealthText.TextColor3 = getColor(flags.esp_health_num_c1, Color3.new(1,1,1))
        end
    else
        b.HealthText.Visible = false
    end
end


run.RenderStepped:Connect(function()
    if not library then return end

    for _, p in ipairs(players:GetPlayers()) do
        if p ~= lp then
            UpdateBronxESP(p)
        end
    end

    if library.menu_open and library.main_frames then
        table.clear(occlusionRects)
        for _, frame in ipairs(library.main_frames) do
            if frame.Visible then
                local ap = frame.AbsolutePosition
                local as = frame.AbsoluteSize
                table.insert(occlusionRects, {x=ap.X, y=ap.Y, w=as.X, h=as.Y})
            end
        end
    else
        table.clear(occlusionRects)
    end

    -- Logic change: Bind ESP_SETTINGS.Enabled directly to the checkbox.
    -- This prevents ESP from disabling when the menu is open.
    ESP_SETTINGS.Enabled = flags.esp_enabled_dummy

    
     local lockKeyActive
    if flags.toggle_auto_aim then
        lockKeyActive = uis:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)
    else
        lockKeyActive = flags.keybind_camera_lock and flags.keybind_camera_lock.active
    end

    local isLocked = flags.toggle_camera_lock and not (flags.toggle_silent_camlock or false) and lockKeyActive

    if isLocked then
        LockCameraToTargetPlayer()
        if CurrentTarget then
            if not wasLocked then
                cas:BindAction("CamLockInputSink", SinkInput, false, Enum.UserInputType.MouseMovement, Enum.UserInputType.Touch, Enum.UserInputType.Gamepad1, Enum.UserInputType.Gamepad2)
                wasLocked = true
            end
        else
            if wasLocked then
                cas:UnbindAction("CamLockInputSink")
                wasLocked = false
            end
        end
    else
        if wasLocked then
            cas:UnbindAction("CamLockInputSink")
            wasLocked = false
        end
        clearHighlight()
        CurrentTarget = nil
    end



    
    local center = Vector2.new(camera.ViewportSize.X/2, camera.ViewportSize.Y/2)

    if FOVCircle then
        local visible = not library.menu_open
        local dotted = flags.toggle_dotted_fov
        if visible and dotted then
            FOVCircle.Visible = false
            if FOVOutline then FOVOutline.Visible = false end
            updateDotted(FOVMiniDots, center, TargetFOV * 5, FOVColor, true, DottedParams.Num_Dots, DottedParams.Dotted_Size)
        else
            updateDotted(FOVMiniDots, center, TargetFOV * 5, FOVColor, false, DottedParams.Num_Dots, DottedParams.Dotted_Size)
            FOVCircle.Visible = visible
            if FOVCircle.Visible then
                FOVCircle.Position = center
                FOVCircle.Radius = TargetFOV * 5
            end
            if FOVOutline then
                FOVOutline.Visible = visible
                if FOVOutline.Visible then
                    FOVOutline.Position = center
                    FOVOutline.Radius = (TargetFOV * 5) + 4
                end
            end
        end
    else
        updateDotted(FOVMiniDots, center, 0, FOVColor, false, 0, 0)
    end

    if SilentFOVCircle then
        local visible = not library.menu_open
        local dotted = flags.toggle_dotted_fov_silent
        if visible and dotted then
            SilentFOVCircle.Visible = false
            if SilentFOVOutline then SilentFOVOutline.Visible = false end
            updateDotted(SilentFOVMiniDots, center, SilentTargetFOV * 5, SilentFOVColor, true, DottedParams.Num_Dots, DottedParams.Dotted_Size)
        else
            updateDotted(SilentFOVMiniDots, center, SilentTargetFOV * 5, SilentFOVColor, false, DottedParams.Num_Dots, DottedParams.Dotted_Size)
            SilentFOVCircle.Visible = visible
            if SilentFOVCircle.Visible then
                SilentFOVCircle.Position = center
                SilentFOVCircle.Radius = SilentTargetFOV * 5
            end
            if SilentFOVOutline then
                SilentFOVOutline.Visible = visible
                if SilentFOVOutline.Visible then
                    SilentFOVOutline.Position = center
                    SilentFOVOutline.Radius = (SilentTargetFOV * 5) + 4
                end
            end
        end
    else
        updateDotted(SilentFOVMiniDots, center, 0, SilentFOVColor, false, 0, 0)
    end

    

    
    if flags.esp_enabled_dummy then
        -- Logic update: scp_chams_toggle acts as a MASTER switch for all SCP visuals.
        local scpMasterEnabled = flags.scp_chams_toggle
        
        local showName = flags.scp_name_toggle
        local showDistance = flags.scp_distance_toggle
        local forceSee = false
        local showHighlight = false

        -- Check dropdown options (Merge with toggles)
        local options = flags.scp_options_dummy or {}
        if type(options) == "table" then
             for _, v in pairs(options) do
                 if v == "ForceSee" then forceSee = true end
                 if v == "Name" then showName = true end
                 if v == "Distance" then showDistance = true end
             end
        end

        if scpMasterEnabled then
            showHighlight = true
            
            if forceSee then
                showHighlight = false
                
                 -- Live update loop: Sync clone parts with real SCP parts every frame
                 for realModel, clone in pairs(SCPViewportCache) do
                     if realModel and realModel.Parent and clone and clone.Parent then
                         local realRoot = realModel.PrimaryPart or realModel:FindFirstChild("HumanoidRootPart")
                         if realRoot then
                             for _, realPart in ipairs(realModel:GetChildren()) do
                                 if realPart:IsA("BasePart") then
                                     local clonePart = clone:FindFirstChild(realPart.Name)
                                     if clonePart and clonePart:IsA("BasePart") then
                                         clonePart.CFrame = realPart.CFrame
                                         clonePart.Color = realPart.Color
                                         clonePart.Material = realPart.Material
                                         clonePart.Transparency = realPart.Transparency
                                     end
                                 end
                             end
                         end
                     end
                 end
            end
        else
            -- Master switch OFF -> Disable all
            showName = false
            showDistance = false
            forceSee = false
            showHighlight = false
        end

        if tick() - lastSCPScan > 0.5 then
            lastSCPScan = tick()
            for m, hl in pairs(SCPESPCache) do
                if not m or not m.Parent then
                    if hl then hl:Destroy() end
                    SCPESPCache[m] = nil
                end
            end
            for m, bb in pairs(SCPNameCache) do
                if not m or not m.Parent then
                    if bb then bb:Destroy() end
                    SCPNameCache[m] = nil
                end
            end
            for m, clone in pairs(SCPViewportCache) do
                if not m or not m.Parent then
                    if clone then clone:Destroy() end
                    SCPViewportCache[m] = nil
                end
            end
            for d, _ in pairs(SCPCandidateCache) do
                if d and d.Parent then
                    -- Filter out non-humanoid SCPs (static props that slipped through)
                    -- Exception for specific SCPs: Allow if it's likely the entity (has a root part)
                    local isExceptionSCP = false
                    local lowerName = string.lower(d.Name)
                    -- Expanded check: Explicit list OR generic "SCP-XXX" pattern
                    if lowerName:find("066") or lowerName:find("999") or lowerName:find("682") or lowerName:find("076") or lowerName:find("023") or lowerName:find("096") or lowerName:find("131") or lowerName:find("457") or lowerName:find("1048") or lowerName:match("scp%s*-%s*%d+") then
                        
                        -- DOUBLE CHECK: Ensure no useless props slipped through the cache logic
                        if not (lowerName:find("door") or lowerName:find("camera") or lowerName:find("sign") or lowerName:find("button") or lowerName:find("terminal") or lowerName:find("glass") or lowerName:find("label") or lowerName:find("screen")) then
                            local root = d.PrimaryPart or d:FindFirstChild("HumanoidRootPart")
                            if not root then
                                 -- TIGHTENED CHECK: Only accept if we find a specific BODY PART.
                                 -- Removed "Body" and "Main" as they are too generic for props.
                                 local bodyParts = {"Head", "Torso", "UpperTorso", "LowerTorso", "HumanoidRootPart", "Root", "Hitbox", "Eye"}
                                 for _, partName in ipairs(bodyParts) do
                                     local found = d:FindFirstChild(partName, true) -- Recursive search
                                     if found and found:IsA("BasePart") then
                                         root = found
                                         break
                                     end
                                 end
                                 
                                 -- Fallback for 066 (Eric) or others that might be just a MeshPart
                                if not root and (lowerName:find("066") or lowerName:find("131") or lowerName:find("087")) then
                                    root = d:FindFirstChildWhichIsA("MeshPart", true) or d:FindFirstChildWhichIsA("BasePart", true)
                                end
                            end
                            
                            -- We already filtered out "camera", "room" etc in updateSCPCandidate, so if we have a root, it's likely the SCP.
                            if root then
                                -- Extra check: Most valid SCP mobs are unanchored. Static props (cameras, meshes) are anchored.
                                if not root.Anchored or lowerName:find("087") then
                                    isExceptionSCP = true
                                end
                            end
                        end
                    end

                    if not d:FindFirstChildOfClass("Humanoid") and not isExceptionSCP then
                        if SCPESPCache[d] then
                            SCPESPCache[d]:Destroy()
                            SCPESPCache[d] = nil
                        end
                        if SCPNameCache[d] then
                            SCPNameCache[d]:Destroy()
                            SCPNameCache[d] = nil
                        end
                        if SCPViewportCache[d] then
                            SCPViewportCache[d]:Destroy()
                            SCPViewportCache[d] = nil
                        end
                        continue
                    end

                    -- Handle ForceSee (Viewport)
                    if forceSee then
                        if not SCPViewportCache[d] then
                            d.Archivable = true
                            local clone = d:Clone()
                            if clone then
                                for _, c in ipairs(clone:GetDescendants()) do
                                    if c:IsA("LuaSourceContainer") or 
                                       c:IsA("LayerCollector") or 
                                       c:IsA("Sound") or 
                                       c:IsA("Light") or 
                                       c:IsA("ParticleEmitter") or c:IsA("Trail") or c:IsA("Beam") or c:IsA("Fire") or c:IsA("Smoke") or c:IsA("Sparkles") or 
                                       c:IsA("ProximityPrompt") or c:IsA("ClickDetector") or c:IsA("TouchTransmitter") or 
                                       c:IsA("Highlight") then
                                        c:Destroy()
                                    elseif c:IsA("BasePart") then
                                        if c.Transparency == 1 then
                                            if c ~= clone.PrimaryPart and c.Name ~= "HumanoidRootPart" then
                                                c:Destroy()
                                            else
                                                c.Transparency = 1
                                            end
                                        end
                                    end
                                end
                                clone.Parent = ViewportFrame
                                SCPViewportCache[d] = clone
                            end
                        end
                    else
                        if SCPViewportCache[d] then
                            SCPViewportCache[d]:Destroy()
                            SCPViewportCache[d] = nil
                        end
                    end

                    local posPart = d.PrimaryPart or d:FindFirstChild("HumanoidRootPart")
                    if not posPart then
                        for _, ch in ipairs(d:GetChildren()) do
                            if ch:IsA("BasePart") then posPart = ch break end
                        end
                    end
                    local within = true
                    if posPart then
                        local dist = (camera.CFrame.Position - posPart.Position).Magnitude
                        within = dist <= SCPRenderDistance
                    end
                    if not within then
                        if SCPESPCache[d] then
                            SCPESPCache[d]:Destroy()
                            SCPESPCache[d] = nil
                        end
                        if SCPNameCache[d] then
                            SCPNameCache[d]:Destroy()
                            SCPNameCache[d] = nil
                        end
                    elseif showHighlight then
                        if not SCPESPCache[d] then
                            local hl = Instance.new("Highlight")
                            hl.Adornee = d
                            local teamName = nil
                            local tv = d:FindFirstChild("Team")
                            if tv and tv:IsA("StringValue") then
                                teamName = tv.Value
                            elseif d:GetAttribute("Team") then
                                teamName = d:GetAttribute("Team")
                            else
                                local n = string.lower(d.Name)
                                if n:find("class") or n:find("d%-") or n:find("class d") then teamName = "Class - D"
                                elseif n:find("security") then teamName = "Security Department"
                                elseif n:find("mtf") or n:find("task force") then teamName = "Mobile Task Force"
                                elseif n:find("chaos") then teamName = "Chaos Insurgency"
                                elseif n:find("scientific") or n:find("science") then teamName = "Scientific Department"
                                elseif n:find("medical") then teamName = "Medical Department"
                                elseif n:find("admin") then teamName = "Administrative Department"
                                elseif n:find("intel") then teamName = "Intelligence Agency"
                                elseif n:find("internal security") then teamName = "Internal Security Department"
                                elseif n:find("rapid response") or n:find("rrt") then teamName = "Rapid Response Team"
                                end
                            end
                            local fillColor = getFlagColor(flags.scp_chams_fill_color, Color3.fromRGB(218, 81, 157))
                            local outlineColor = getFlagColor(flags.scp_chams_outline_color, Color3.new(0, 0, 0))
                            hl.FillColor = fillColor
                            hl.OutlineColor = outlineColor
                            hl.FillTransparency = 0.6
                            hl.OutlineTransparency = 0
                            hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                            hl.Parent = d
                            SCPESPCache[d] = hl
                        end
                    elseif SCPESPCache[d] then
                        SCPESPCache[d]:Destroy()
                        SCPESPCache[d] = nil
                    end
                    
                    
                    if within and (showName or showDistance) and not SCPNameCache[d] then
                        local adornee = d:FindFirstChild("HumanoidRootPart") or d.PrimaryPart
                        if not adornee then
                            for _, ch in ipairs(d:GetChildren()) do
                                if ch:IsA("BasePart") then adornee = ch break end
                            end
                        end
                        if adornee then
                            local bb = Instance.new("BillboardGui")
                            bb.Parent = d
                            bb.Adornee = adornee
                            bb.Size = UDim2.new(0, 120, 0, 24)
                            bb.StudsOffset = Vector3.new(4, 0.5, 0)
                            bb.AlwaysOnTop = true
                            local tl = Instance.new("TextLabel")
                            tl.Parent = bb
                            tl.Size = UDim2.new(1, 0, 1, 0)
                            tl.BackgroundTransparency = 1
                            tl.TextScaled = false
                            -- Force hardcoded font and size as requested
                            tl.Font = Enum.Font.RobotoMono
                            tl.TextSize = 10
                            tl.TextStrokeTransparency = 0
                            tl.TextStrokeColor3 = Color3.new(0,0,0)
                            tl.TextXAlignment = Enum.TextXAlignment.Left
                            tl.TextYAlignment = Enum.TextYAlignment.Center
                            tl.AnchorPoint = Vector2.new(0, 0.5)
                            tl.Position = UDim2.fromScale(0.5, 0.5)
                            local teamName = nil
                            local tv = d:FindFirstChild("Team")
                            if tv and tv:IsA("StringValue") then
                                teamName = tv.Value
                            elseif d:GetAttribute("Team") then
                                teamName = d:GetAttribute("Team")
                            end
                            local col = RoleColors[teamName] or Color3.fromRGB(255,255,255)
                            tl.TextColor3 = col
                            local lowerName = string.lower(d.Name)
                            if lowerName:find("966") then
                                tl.Text = "SCP - 966\nSleep Killer"
                            elseif lowerName:find("066") then
                                tl.Text = "SCP - 066\nEric"
                            elseif lowerName:find("457") then
                                tl.Text = "SCP - 457\nBurning Man"
                            elseif lowerName:find("023") then
                                tl.Text = "SCP - 023\nBlack Shuck"
                            elseif lowerName:find("173") then
                                tl.Text = "SCP - 173\nThe Sculpture"
                            elseif lowerName:find("096") then
                                tl.Text = "SCP - 096\nThe Shy Guy"
                            elseif lowerName:find("106") then
                                tl.Text = "SCP - 106\nThe Old Man"
                            elseif lowerName:find("049") then
                                if lowerName:find("2") then
                                    tl.Text = "SCP - 049-2\nCured"
                                else
                                    tl.Text = "SCP - 049\nThe Plague Doctor"
                                end
                            elseif lowerName:find("939") then
                                tl.Text = "SCP - 939\nWith Many Voices"
                            elseif lowerName:find("076") then
                                tl.Text = "SCP - 076\nAble"
                            elseif lowerName:find("035") then
                                tl.Text = "SCP - 035\nPossessive Mask"
                            elseif lowerName:find("008") then
                                tl.Text = "SCP - 008\nZombie"
                            elseif lowerName:find("682") then
                                tl.Text = "SCP - 682\nHard-to-Destroy Reptile"
                            elseif lowerName:find("1048") then
                                tl.Text = "SCP - 1048\nBuilder Bear"
                            elseif lowerName:find("002") then
                                tl.Text = "SCP - 002\nThe Living Room"
                            elseif lowerName:find("999") then
                                tl.Text = "SCP - 999\nThe Tickle Monster"
                            elseif lowerName:find("131") then
                                tl.Text = "SCP - 131\nThe Eye Pods"
                            elseif lowerName:find("087") then
                                tl.Text = "SCP - 087-1\nThe Face"
                            else
                                tl.Text = d.Name
                            end
                            SCPNameCache[d] = bb
                            tl:SetAttribute("BaseText", tl.Text)
                        end
                    end
                elseif SCPESPCache[d] then
                    local hl = SCPESPCache[d]
                    local teamName = nil
                    local tv = d:FindFirstChild("Team")
                    if tv and tv:IsA("StringValue") then
                        teamName = tv.Value
                    elseif d:GetAttribute("Team") then
                        teamName = d:GetAttribute("Team")
                    end
                    if teamName then
                        local color = RoleColors[teamName] or hl.OutlineColor
                        hl.OutlineColor = color
                        local bb = SCPNameCache[d]
                        if bb then
                            local tl = bb:FindFirstChildOfClass("TextLabel")
                            if tl then tl.TextColor3 = color end
                        end
                    end
                end
            end
            if not showName and not showDistance then
                for m, bb in pairs(SCPNameCache) do
                    if bb then bb:Destroy() end
                    SCPNameCache[m] = nil
                end
            end
        end
        
        
        for m, bb in pairs(SCPNameCache) do
            if bb and m and m.Parent then
                local pos = m:GetPivot().Position
                local screenPos, onScreen = camera:WorldToViewportPoint(pos)
                if onScreen and not isOccluded(Vector2.new(screenPos.X, screenPos.Y)) then
                    bb.Enabled = (showName or showDistance)
                    local tl = bb:FindFirstChildOfClass("TextLabel")
                    if tl and bb.Enabled then
                        -- Update layout
                        bb.StudsOffset = Vector3.new(4, 0.5, 0)
                        tl.TextXAlignment = Enum.TextXAlignment.Left
                        tl.AnchorPoint = Vector2.new(0, 0.5)
                        tl.Position = UDim2.fromScale(0.5, 0.5)

                        local base = tl:GetAttribute("BaseText") or tl.Text
                        local text = ""
                        if showName then
                            text = base
                        end
                        if showDistance then
                            local dist = math.floor((camera.CFrame.Position - pos).Magnitude)
                            if text ~= "" then
                                text = text .. " [" .. dist .. "m]"
                            else
                                text = "[" .. dist .. "m]"
                            end
                        end
                        tl.Text = text
                    end
                else
                    bb.Enabled = false
                end
            elseif bb then
                bb.Enabled = false
            end
        end
        for m, hl in pairs(SCPESPCache) do
            if hl and m and m.Parent then
                local pos = m:GetPivot().Position
                local screenPos, onScreen = camera:WorldToViewportPoint(pos)
                if onScreen and not isOccluded(Vector2.new(screenPos.X, screenPos.Y)) then
                    hl.Enabled = showHighlight
                else
                    hl.Enabled = false
                end
            elseif hl then
                hl.Enabled = false
            end
        end
    else
        for m, hl in pairs(SCPESPCache) do
            if hl then hl:Destroy() end
            SCPESPCache[m] = nil
        end
        for m, bb in pairs(SCPNameCache) do
            if bb then bb:Destroy() end
            SCPNameCache[m] = nil
        end
        for m, clone in pairs(SCPViewportCache) do
            if clone then clone:Destroy() end
            SCPViewportCache[m] = nil
        end
    end

    if ESP_SETTINGS.Enabled then
        local now = tick()
        local doEspUpdate = (now - lastEspUpdate) >= espUpdateInterval
        local doTextUpdate = (now - lastTextUpdate) >= textUpdateInterval
        
        if doEspUpdate then lastEspUpdate = now end
        if doTextUpdate then lastTextUpdate = now end
        
        for _, p in ipairs(players:GetPlayers()) do
            if p ~= lp and p.Character and p.Character:FindFirstChildOfClass("Humanoid") and p.Character:FindFirstChild("Humanoid").Health > 0 then
                local root = p.Character:FindFirstChild("HumanoidRootPart")
                if root then
                    local dist = (camera.CFrame.Position - root.Position).Magnitude
                    
                    if dist <= ESPRenderDistance then
                        if not ESPCache[p] then setupESPCache(p) end
                    end
                    
                    local centerOn = characterCenterOnScreen(p.Character)
                     if dist <= ESPRenderDistance and centerOn then
                        if not ESPCache[p] then
                            setupESPCache(p)
                        end
                        ESPCache[p].isVisible = true
                            local minX, minY, maxX, maxY = computeAABB(p.Character)
                            if validateBox(minX, minY, maxX, maxY) then
                                minX, minY, maxX, maxY = clampBox(minX, minY, maxX, maxY)
                                local prev = ESPCache[p]
                                
                                prev.box_prev_minX, prev.box_prev_minY, prev.box_prev_maxX, prev.box_prev_maxY = minX, minY, maxX, maxY
                                prev.box_prev_valid = true
                                local w, h = maxX - minX, maxY - minY
                                local boxColor = color
                                local font = DrawingFontFromName(flags.settings_font_dummy or "Minecraft")
                                local baseSize = tonumber(flags.esp_font_size_dummy) or 13
                                if baseSize < 8 then baseSize = 8 end
                                local ts = baseSize
                                
                                local nameText = ESPCache[p].name_text
                                local distText = ESPCache[p].dist_text
                                
                                
                                local padding = math.max(3, math.floor(ts * 0.35))
                                
                                local hideESP = false

                                if flags.esp_names then
                                    local nPos = Vector2.new(maxX + padding, minY)
                                    if isOccluded(nPos) or hideESP then
                                        nameText.Visible = false
                                    else
                                        nameText.Position = nPos
                                        nameText.Visible = true
                                    end
                                    
                                    if doTextUpdate then
                                        nameText.Text = p.Name
                                        nameText.Color = boxColor
                                        nameText.Font = font
                                        nameText.Size = ts
                                    end
                                else
                                    nameText.Visible = false
                                end
                                if flags.esp_distance_text then
                                    local offsetY = 0
                                    if flags.esp_names then
                                        offsetY = ts + math.max(1, math.floor(padding * 0.5))
                                    end
                                    local dPos = Vector2.new(maxX + padding, minY + offsetY)
                                    if isOccluded(dPos) or hideESP then
                                        distText.Visible = false
                                    else
                                        distText.Position = dPos
                                        distText.Visible = true
                                    end

                                    if doTextUpdate then
                                        distText.Text = tostring(math.floor(dist)) .. "m"
                                        distText.Color = boxColor
                                        distText.Font = font
                                        distText.Size = ts
                                    end
                                else
                                    distText.Visible = false
                                end
                                
                                ESPCache[p].health_text.Visible = false
                                local hbBack = ESPCache[p].health_back
                                local hbFront = ESPCache[p].health_front
                                local hbBackO = ESPCache[p].health_back_outline
                                local hbFrontO = ESPCache[p].health_front_outline
                                hbBack.Visible = false
                                hbFront.Visible = false
                                if hbBackO then hbBackO.Visible = false end
                                if hbFrontO then hbFrontO.Visible = false end
                                if flags.esp_chams then
                                    local hl = PlayerChamsCache[p]
                                    if not hl then
                                        hl = Instance.new("Highlight")
                                        hl.Adornee = p.Character
                                        hl.Parent = p.Character
                                        PlayerChamsCache[p] = hl
                                    end
                                    hl.FillColor = Color3.new(0,0,0)
                                    hl.FillTransparency = 0.6
                                    hl.OutlineColor = boxColor
                                    hl.OutlineTransparency = 0
                                    hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                                    hl.Enabled = true
                                else
                                    if PlayerChamsCache[p] then
                                        PlayerChamsCache[p].Enabled = false
                                    end
                                end
                            else
                                hidePlayerESP(p, true)
                                if PlayerChamsCache[p] then PlayerChamsCache[p].Enabled = false end
                            end
                    else
                        if dist <= ESPRenderDistance then
                            hidePlayerESP(p, true)
                        else
                            hidePlayerESP(p)
                        end
                        if PlayerChamsCache[p] then PlayerChamsCache[p].Enabled = false end
                    end
                else
                    hidePlayerESP(p)
                    if PlayerChamsCache[p] then PlayerChamsCache[p].Enabled = false end
                end
            elseif ESPCache[p] then
                hidePlayerESP(p)
                if PlayerChamsCache[p] then PlayerChamsCache[p].Enabled = false end
            end
        end
    else
        
        for _, p in ipairs(players:GetPlayers()) do
            if ESPCache[p] then
                hidePlayerESP(p)
                if PlayerChamsCache[p] then PlayerChamsCache[p].Enabled = false end
            end
        end
    end
end)

local desyncStatusText

-- [[ Desync Logic ]]
do

    local oldIndex
    oldIndex = hookmetamethod(game, "__index", function(self, index)
        if not checkcaller() and library.flags["desync_server"] and library.DesyncData.RealCFrame and (index == "CFrame" or index == "Position") and lp.Character and self == lp.Character.HumanoidRootPart then
             if index == "Position" then
                 return library.DesyncData.RealCFrame.Position
             end
             return library.DesyncData.RealCFrame
        end
        return oldIndex(self, index)
    end)

    --// Create 2D Image Indicator
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "Desync Indicator GUI"
    screenGui.ResetOnSpawn = false
    
    if gethui then
        screenGui.Parent = gethui()
    elseif game:GetService("CoreGui") then
        screenGui.Parent = game:GetService("CoreGui")
    else
        screenGui.Parent = lp:WaitForChild("PlayerGui")
    end
    
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

    -- Create a background circle for better visibility
    local backgroundCircle = Instance.new("ImageLabel")
    backgroundCircle.Name = "Background Circle"
    backgroundCircle.Size = UDim2.new(0, 40, 0, 40)
    backgroundCircle.AnchorPoint = Vector2.new(0.5, 0.5)
    backgroundCircle.Position = UDim2.new(0.5, 0, 0.5, 0)
    backgroundCircle.BackgroundTransparency = 1
    backgroundCircle.Image = "rbxassetid://3570695787" -- Circle asset
    backgroundCircle.ImageColor3 = Color3.fromRGB(0, 0, 0)
    backgroundCircle.ImageTransparency = 0.5
    backgroundCircle.Visible = false
    backgroundCircle.ZIndex = 9
    backgroundCircle.Parent = screenGui

    local imageIndicator = Instance.new("ImageLabel")
    imageIndicator.Name = "Desync Indicator"
    imageIndicator.Size = UDim2.new(0, 20, 0, 20)
    imageIndicator.AnchorPoint = Vector2.new(0.5, 0.5)
    imageIndicator.Position = UDim2.new(0.5, 0, 0.5, 0)
    imageIndicator.BackgroundTransparency = 1
    imageIndicator.Image = "rbxassetid://10723415903" -- Material Person Icon
    imageIndicator.ImageTransparency = 0
    imageIndicator.Visible = false
    imageIndicator.ZIndex = 10
    imageIndicator.Parent = screenGui

    local desyncInfoItem = nil
    local autoDesyncActive = false

    local CurrentServerCFrame = nil

    local currentRelativeCFrame = CFrame.new(0, 0, 0)

    run.Heartbeat:Connect(function(dt)
        local enabled = library.flags["desync_server"]
        local char = lp.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        
        if not root then
            library.DesyncData.RealCFrame = nil
            CurrentServerCFrame = nil
            return
        end
        
        -- Initialize currentRelativeCFrame if needed
        if not currentRelativeCFrame then currentRelativeCFrame = CFrame.new(0, 0, 0) end

        -- Check Aiming (Unified Logic)
        local aiming = false
        local tool = char:FindFirstChildWhichIsA("Tool")
        if tool and uis:IsMouseButtonPressed(Enum.UserInputType.MouseButton2) and not autoDesyncActive then
            aiming = true
        end

        local shouldDesync = enabled and not aiming

        -- Smooth Ramp Down Check
        local isEffectivelyZero = currentRelativeCFrame.Position.Magnitude < 0.05 -- Increased from 0.01 to 0.05 to prevent sticking
        
        if not shouldDesync and isEffectivelyZero then
            library.DesyncData.RealCFrame = nil
            CurrentServerCFrame = root.CFrame
            
            if library.remove_info_item then
                library:add_info_item("Desync Status", "Disabled", Color3.fromRGB(255, 0, 0))
                library:remove_info_item("Desync Mode")
                library:remove_info_item("Desync Offset")
                library:remove_info_item("Detected")
                if library.info_list_frame then
                    library.info_list_frame.Visible = true
                end
            end
            
            currentRelativeCFrame = CFrame.new(0, 0, 0)
            return 
        end

        -- Calculate Target Relative CFrame
        local targetRelative = CFrame.new() -- Replaced CFrame.Identity for safety
        local mode = library.flags["desync_mode"] or "Custom"
        
        if shouldDesync then
            if mode == "Underground" then
                local worldOffset = Vector3.new(0, -10, 0)
                local targetPos = root.Position + worldOffset
                local absRot = CFrame.Angles(0, 0, math.rad(180))
                targetRelative = root.CFrame:Inverse() * (CFrame.new(targetPos.X, targetPos.Y, targetPos.Z) * absRot)
            elseif mode == "SCP" then
                local yOffset = 0 -- Default to 0 (Normal Position) when no SCP detected
                local zOffset = 0
                
                if library.DesyncData.DetectedSCP then
                    if library.DesyncData.Has066 then
                        yOffset = -85
                        if library.DesyncData.DetectedSCP == "Multiple" then
                            zOffset = 20
                        end
                    elseif library.DesyncData.DetectedSCP == "Multiple" then
                        yOffset = -75
                        zOffset = 20
                    else
                         yOffset = -30
                    end
                end
                
                local worldOffset = Vector3.new(0, yOffset, zOffset)
                local targetPos = root.Position + worldOffset
                local absRot = CFrame.Angles(0, 0, math.rad(180))
                targetRelative = root.CFrame:Inverse() * (CFrame.new(targetPos.X, targetPos.Y, targetPos.Z) * absRot)
            else -- Custom
                 local x = tonumber(library.flags["desync_offset_x"]) or 0
                 local y = tonumber(library.flags["desync_offset_y"]) or 0
                 local z = tonumber(library.flags["desync_offset_z"]) or 0
                 local posOffset = Vector3.new(x, y, z)
                 
                 local rotOffset = CFrame.new(0, 0, 0)
                 if library.flags["desync_rot_spoofer"] then
                     local p = tonumber(library.flags["desync_rot_pitch"]) or 0
                     local yaw = tonumber(library.flags["desync_rot_yaw"]) or 0
                     local r = tonumber(library.flags["desync_rot_roll"]) or 0
                     
                     if library.flags["desync_invert"] then
                         p = -p
                         yaw = -yaw
                         r = -r
                     end
                     
                     rotOffset = CFrame.Angles(p, yaw, r)
                end
                 
                 targetRelative = CFrame.new(posOffset.X, posOffset.Y, posOffset.Z) * rotOffset
            end
        end

        -- Smooth Transition
        if not currentRelativeCFrame then currentRelativeCFrame = CFrame.new(0, 0, 0) end
        
        -- Safety check to prevent "Argument 2 missing or nil"
        if not targetRelative then targetRelative = CFrame.new(0, 0, 0) end
        
        if dt and type(dt) == "number" then
            local lerpSpeed = 2 -- Default speed for smooth activation
            if not shouldDesync then
                lerpSpeed = 6 -- Faster speed for disabling/ramp down to avoid long wait
            end
            currentRelativeCFrame = currentRelativeCFrame:Lerp(targetRelative, math.min(dt * lerpSpeed, 1))
        else
            currentRelativeCFrame = targetRelative
        end

        local ServerCFrame = root.CFrame * currentRelativeCFrame
        CurrentServerCFrame = ServerCFrame
        library.DesyncData.RealCFrame = root.CFrame
        root.CFrame = ServerCFrame

        if library.add_info_item then
             if shouldDesync then
                 library:add_info_item("Desync Status", "Enabled", Color3.fromRGB(0, 255, 0))
                 library:add_info_item("Desync Mode", mode)
                 
                 local relPos = currentRelativeCFrame.Position
                 library:add_info_item("Desync Offset", string.format("%.1f, %.1f, %.1f", relPos.X, relPos.Y, relPos.Z))
             elseif not isEffectivelyZero then
                 library:add_info_item("Desync Status", "Disabling...", Color3.fromRGB(255, 165, 0))
                 library:add_info_item("Desync Offset", string.format("%.1f, %.1f, %.1f", currentRelativeCFrame.Position.X, currentRelativeCFrame.Position.Y, currentRelativeCFrame.Position.Z))
             end
        end
    end)

    run.RenderStepped:Connect(function(dt)
        local char = lp.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        
        -- Restore RealCFrame
        if library.DesyncData.RealCFrame and root then
            root.CFrame = library.DesyncData.RealCFrame
        end

        -- Update Indicator
        -- local enabled = library.flags["desync_server"] -- Removed to allow visualization when disabled
        local visualize = library.flags["desync_visualize"]
        local camera = ws.CurrentCamera

        if not visualize or not root or not CurrentServerCFrame or not camera then
            imageIndicator.Visible = false
            backgroundCircle.Visible = false
            smoothedPos = nil
            return
        end

        -- Visualization Logic
        local targetPos = CurrentServerCFrame.Position
        
        -- Attempt to find Torso offset
        local torso = char and char:FindFirstChild("Torso")
        if torso and not torso:IsA("BasePart") then torso = nil end
        if not torso and char then torso = char:FindFirstChild("UpperTorso") end
        if torso and not torso:IsA("BasePart") then torso = nil end

        if torso and root then
             -- Calculate relative offset of Torso from Root in Object Space
             local relCFrame = root.CFrame:ToObjectSpace(torso.CFrame)
             -- Apply that offset to the CurrentServerCFrame
             targetPos = CurrentServerCFrame:ToWorldSpace(relCFrame).Position
        else
             -- Fallback approximate offset if Torso not found (approx 2.5 studs up relative to root)
             targetPos = CurrentServerCFrame:ToWorldSpace(CFrame.new(0, 2.5, 0)).Position
        end

        if not smoothedPos then
            if torso then
                smoothedPos = torso.Position
            elseif root then
                smoothedPos = root.CFrame:ToWorldSpace(CFrame.new(0, 2.5, 0)).Position
            else
                smoothedPos = targetPos
            end
        end

        -- Lerp the position
        local lerpSpeed = 15
        
        local enabled = library.flags["desync_server"]
        -- if not enabled then
        --      -- Increase lerp speed when disabled to snap back faster
        --      lerpSpeed = 25
        -- end

        smoothedPos = smoothedPos:Lerp(targetPos, math.clamp(dt * lerpSpeed, 0, 1))

        local screen_pos, on_screen = camera:WorldToViewportPoint(smoothedPos)
        
        if on_screen and screen_pos.Z > 0 then
            local pos = UDim2.new(0, screen_pos.X, 0, screen_pos.Y)
            imageIndicator.Position = pos
            backgroundCircle.Position = pos
            
            -- Rotation Logic (Visualizes Server Rotation)
            local _, yaw, _ = CurrentServerCFrame:ToEulerAnglesYXZ()
            local _, camYaw, _ = camera.CFrame:ToEulerAnglesYXZ()
            local relativeYaw = yaw - camYaw
            imageIndicator.Rotation = math.deg(-relativeYaw)
            
            local screen_x, screen_y = camera.ViewportSize.X, camera.ViewportSize.Y
            local padding = 20
            local in_bounds = screen_pos.X > padding and screen_pos.X < (screen_x - padding) and 
                             screen_pos.Y > padding and screen_pos.Y < (screen_y - padding)
            
            imageIndicator.Visible = in_bounds
            backgroundCircle.Visible = in_bounds

            local visColor = library.flags["desync_visualize_color"]
            if typeof(visColor) == "table" then
                 if visColor.Color then visColor = visColor.Color end
            end
            if typeof(visColor) == "Color3" then
                 imageIndicator.ImageColor3 = visColor
            end
        else
            imageIndicator.Visible = false
            backgroundCircle.Visible = false
        end
    end)
end

camera = ws.CurrentCamera
lp = players.LocalPlayer 
local mouse = lp:GetMouse() 
local gui_offset = gui_service:GetGuiInset().Y

local max = math.max 
local floor = math.floor 
local min = math.min 
local abs = math.abs 
local noise = math.noise
local rad = math.rad 
local random = math.random 
local pow = math.pow 
local sin = math.sin 
local pi = math.pi 
local tan = math.tan 
local atan2 = math.atan2 
local cos = math.cos 
local round = math.round;
local clamp = math.clamp; 
local ceil = math.ceil; 
local sqrt = math.sqrt;
local acos = math.acos; 

local insert = table.insert 
local find = table.find 
local remove = table.remove
local concat = table.concat




local window = library:window({name = os.date('Home'), size = dim2(0, 567, 0, 580)})

local Aiming = window:tab({name = "Combat"})
local Players = window:tab({name = "Players"})
local Visuals = window:tab({name = "Visuals"})
local Misc = window:tab({name = "Misc"})


Aiming.open_tab() 



    local aimingLeft = Aiming:column()
    local aimingRight = Aiming:column()
    local Combat, CombatVisuals = aimingLeft:multi_section({names = {"Combat", "Visuals"}})

    CombatVisuals:toggle({
        name = "Target HUD", 
        flag = "toggle_target_hud", 
        default = false,
    })

    local TargetHUD = library:indicator()
    TargetHUD.set_visible(false)
    TargetHUD.items.Window.Position = dim2(0.5, -161, 1, -180)
    TargetHUD.items.InfoTitle.Text = "Target"
    
    run.RenderStepped:Connect(function(dt)
        if flags.toggle_target_hud and CurrentTarget and CurrentTarget.Character and CurrentTarget.Character:FindFirstChild("Humanoid") then
            TargetHUD.change_profile(CurrentTarget)
            local hum = CurrentTarget.Character.Humanoid
            TargetHUD.change_health((hum.Health / hum.MaxHealth) * 100)
            TargetHUD.set_visible(true)
        else
            TargetHUD.set_visible(false)
        end
    end)



    local Checks = aimingRight:section({name = "Checks"})
    local miscLeft = Misc:column()
    local miscRight = Misc:column()
    
    local Desync = miscLeft:section({name = "Desync"})
    local Local, Other = miscRight:multi_section({names = {"Local", "Other"}})

    -- Desync Tab
    do
        local serverDesync = Desync:toggle({name = "Server Desync", flag = "desync_server"})
        serverDesync:keybind({
            name = "Server Desync", 
            flag = "keybind_desync_server", 
            mode = "toggle",
            callback = function(active)
                serverDesync.set(active)
            end
        })

        local visualizeDesync = Desync:toggle({
            name = "Visualize Desync",
            flag = "desync_visualize"
        })
        visualizeDesync:colorpicker({
            name = "Visualize Color",
            flag = "desync_visualize_color",
            color = Color3.fromRGB(191, 191, 244)
        })
        
        -- Forward declaration for sliders
        local sliderX, sliderY, sliderZ
        local sliderPitch, sliderYaw, sliderRoll
        local desyncDivider

        local function updateDesyncVis(mode)
            local isCustom = (mode == "Custom")
            
            local function setVis(obj, vis)
                if obj and obj.set_visible then
                    obj.set_visible(vis)
                elseif obj and obj.SetVisible then
                    obj.SetVisible(vis)
                elseif obj and type(obj) == "table" and obj.container then
                     obj.container.Visible = vis
                end
            end
            
            setVis(sliderX, isCustom)
            setVis(sliderY, isCustom)
            setVis(sliderZ, isCustom)
            if desyncDivider then 
                desyncDivider.Visible = isCustom 
            end
            setVis(sliderPitch, isCustom)
            setVis(sliderYaw, isCustom)
            setVis(sliderRoll, isCustom)
        end

        local prevManualDesyncMode = "Custom"
        local autoServerWasEnabled = false
        local desyncMode = Desync:dropdown({
            name = "Mode", 
            flag = "desync_mode",
            items = {"Custom", "Underground"},
            default = "Custom",
            callback = function(mode)
                prevManualDesyncMode = mode
                updateDesyncVis(mode)
            end
        })
        
        Desync:toggle({
            name = "Enable when near SCP",
            flag = "desync_near_scp",
            callback = function(v)
                if v then
                    task.spawn(function()
                        while library.flags["desync_near_scp"] do
                            local myChar = players.LocalPlayer.Character
                            local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
                            local foundSCPs = {}
                            local detectedSCPName = ""
                            
                            if myRoot then
                                -- Iterate over SCPCandidateCache instead of workspace:GetChildren()
                                -- This ensures we find SCPs even if they are deep in folders
                                for scp, _ in pairs(SCPCandidateCache) do
                                    if scp and scp.Parent then
                                        local name = scp.Name:lower()
                                        
                                        -- Filter out safe SCPs and excluded ones
                                        if not name:find("999") and not name:find("131") and not name:find("079") and not name:find("316") and not name:find("camera") and not name:find("scps") then
                                            
                                            -- Use PrimaryPart or Torso/RootPart for distance check
                                            local scpPart = scp.PrimaryPart
                                            if not (scpPart and scpPart:IsA("BasePart")) then
                                                scpPart = nil
                                                for _, pName in ipairs({"HumanoidRootPart", "Torso", "Head", "UpperTorso", "LowerTorso"}) do
                                                    local p = scp:FindFirstChild(pName)
                                                    if p and p:IsA("BasePart") then
                                                        scpPart = p
                                                        break
                                                    end
                                                end
                                            end
                                            
                                            if scpPart then
                                                local dist = (myRoot.Position - scpPart.Position).Magnitude
                                                local radius = 65
                                                if name:find("096") then
                                                    radius = 100
                                                elseif name:find("173") then
                                                    radius = 85
                                                end
                                                if dist < radius then
                                                    table.insert(foundSCPs, scp.Name)
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                            
                            if #foundSCPs > 0 then
                                autoDesyncActive = true
                                if library.DesyncData then library.DesyncData.AutoActive = true end
                                library.flags["desync_mode"] = "SCP"
                                
                                local has066 = false
                                for _, name in ipairs(foundSCPs) do
                                    if name:find("066") then has066 = true break end
                                end
                                if library.DesyncData then library.DesyncData.Has066 = has066 end
                                
                                if #foundSCPs > 1 then
                                    detectedSCPName = "Multiple"
                                    library.DesyncData.DetectedSCP = "Multiple" -- Special flag for multiple SCPs
                                else
                                    detectedSCPName = foundSCPs[1]
                                    library.DesyncData.DetectedSCP = detectedSCPName
                                end

                                if not library.flags["desync_server"] then
                                    library.flags["desync_server"] = true
                                    serverDesync.set(true)
                                    autoServerWasEnabled = true
                                end
                                
                                library:add_info_item("Detected", detectedSCPName, Color3.fromRGB(255, 0, 0))
                                library.info_list_frame.Visible = true
                            else
                                autoDesyncActive = false
                                if library.DesyncData then library.DesyncData.AutoActive = false end
                                library.flags["desync_mode"] = prevManualDesyncMode
                                library.DesyncData.DetectedSCP = nil
                                if library.DesyncData then library.DesyncData.Has066 = false end
                                if autoServerWasEnabled and library.flags["desync_server"] then
                                    library.flags["desync_server"] = false
                                    serverDesync.set(false)
                                    autoServerWasEnabled = false
                                end
                                library:remove_info_item("Detected")
                            end
                            task.wait(0.5)
                        end
                        -- Cleanup when toggle is disabled
                        library:remove_info_item("Detected")
                        autoDesyncActive = false
                        if library.DesyncData then library.DesyncData.AutoActive = false end
                    end)
                else
                    library:remove_info_item("Detected")
                    autoDesyncActive = false
                    if library.DesyncData then library.DesyncData.AutoActive = false end
                end
            end
        })
        
        sliderX = Desync:slider({name = "Custom X Position", flag = "desync_offset_x", min = -30, max = 30, default = 0, decimal = 1})
        sliderY = Desync:slider({name = "Custom Y Position", flag = "desync_offset_y", min = -30, max = 30, default = 0, decimal = 1})
        sliderZ = Desync:slider({name = "Custom Z Position", flag = "desync_offset_z", min = -30, max = 30, default = 0, decimal = 1})
        
        desyncDivider = library:create("Frame", {
            Parent = Desync.holder,
            Name = "Divider",
            Size = UDim2.new(1, -8, 0, 2),
            BorderSizePixel = 0,
            BackgroundColor3 = Color3.fromRGB(45, 45, 45)
        })

        sliderPitch = Desync:slider({name = "Custom X Angle", flag = "desync_rot_pitch", min = -30, max = 30, default = 0, decimal = 1})
        sliderYaw = Desync:slider({name = "Custom Y Angle", flag = "desync_rot_yaw", min = -30, max = 30, default = 0, decimal = 1})
        sliderRoll = Desync:slider({name = "Custom Z Angle", flag = "desync_rot_roll", min = -30, max = 30, default = 0, decimal = 1})
        
        -- Initialize visibility
        updateDesyncVis(library.flags["desync_mode"] or "Custom")
        
    end

    local Movement = Local
    local CharacterMods = Local
    local ChecksMisc = Other
    
    do
        Movement:toggle({
            name = "No Jump Cooldown",
            flag = "no_jump_cooldown",
            default = false,
            callback = function(v)
                local char = players.LocalPlayer.Character
                if char then
                    local hum = char:FindFirstChildOfClass("Humanoid")
                    if hum then
                        hum.UseJumpPower = not v
                    end
                end
            end
        })

        local noFallConn
        local noFallCharConn
        local function setupNoFall(char)
            if not char then return end
            local hum = char:WaitForChild("Humanoid", 1)
            local root = char:WaitForChild("HumanoidRootPart", 1)
            if not hum or not root then return end
            
            -- Logic from nofalldamage.txt
            local distance = 3
            local waitDelay = 0.2
            local minDropHeight = distance * 4
            local minFreefallTime = 0.35
            local minDownSpeed = 30
            
            local isFalling = false
            local fallStartY = 0
            local fallStartTime = 0
            
            if noFallConn then noFallConn:Disconnect() end
            noFallConn = hum.StateChanged:Connect(function(old, new)
                if new == Enum.HumanoidStateType.Freefall and not isFalling then
                    isFalling = true
                    fallStartY = root.Position.Y
                    fallStartTime = tick()
                elseif old == Enum.HumanoidStateType.Freefall and new ~= Enum.HumanoidStateType.Freefall then
                    if isFalling then
                        local dropDist = math.max(0, fallStartY - root.Position.Y)
                        local freefallTime = tick() - fallStartTime
                        local downSpeed = math.max(0, -(root.Velocity.Y))
                        
                        if dropDist >= minDropHeight or freefallTime >= minFreefallTime or downSpeed >= minDownSpeed then
                            hum.PlatformStand = true
                            root.Velocity = Vector3.zero
                            task.delay(waitDelay, function()
                                if hum and hum.Parent then
                                    hum.PlatformStand = false
                                end
                            end)
                        end
                        isFalling = false
                    end
                end
            end)
        end

        Movement:toggle({
            name = "No Fall Damage",
            flag = "no_fall_damage",
            default = false,
            callback = function(v)
                if v then
                    local char = players.LocalPlayer.Character
                    if char then setupNoFall(char) end
                    noFallCharConn = players.LocalPlayer.CharacterAdded:Connect(setupNoFall)
                else
                    if noFallConn then noFallConn:Disconnect() end
                    noFallConn = nil
                    if noFallCharConn then noFallCharConn:Disconnect() end
                    noFallCharConn = nil
                end
            end
        })

        local autoAimConnBegan, autoAimConnEnded
        Movement:toggle({
            name = "Auto Aim",
            flag = "toggle_auto_aim",
            default = false,
            callback = function(v)
                local vim = game:GetService("VirtualInputManager")
                local uis = game:GetService("UserInputService")
                
                if v then
                    -- Check initial state
                    if uis:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
                        vim:SendMouseButtonEvent(0, 0, 1, true, game, 1)
                    end
                    
                    if autoAimConnBegan then autoAimConnBegan:Disconnect() end
                    if autoAimConnEnded then autoAimConnEnded:Disconnect() end

                    autoAimConnBegan = uis.InputBegan:Connect(function(input, gpe)
                        if gpe then return end
                        if input.UserInputType == Enum.UserInputType.MouseButton1 then
                            vim:SendMouseButtonEvent(0, 0, 1, true, game, 1)
                        end
                    end)
                    
                    autoAimConnEnded = uis.InputEnded:Connect(function(input, gpe)
                        if input.UserInputType == Enum.UserInputType.MouseButton1 then
                            vim:SendMouseButtonEvent(0, 0, 1, false, game, 1)
                        end
                    end)
                else
                    if autoAimConnBegan then autoAimConnBegan:Disconnect() end
                    if autoAimConnEnded then autoAimConnEnded:Disconnect() end
                    autoAimConnBegan = nil
                    autoAimConnEnded = nil
                    vim:SendMouseButtonEvent(0, 0, 1, false, game, 1)
                end
            end
        })

        do
        local autoRunConn, autoRunInputConn, autoRunCharConn
        local autoRunToggle = Movement:toggle({
            name = "Auto Run",
            flag = "toggle_auto_run",
            default = false,
            callback = function(v)
                local vim = game:GetService("VirtualInputManager")
                local rs = game:GetService("RunService")
                local uis = game:GetService("UserInputService")
                local players = game:GetService("Players")
                
                if v then
                    -- Reset State
                    local isCrouchPaused = false
                    local lastToggleTime = 0
                    
                    if autoRunConn then autoRunConn:Disconnect() end
                    if autoRunInputConn then autoRunInputConn:Disconnect() end
                    if autoRunCharConn then autoRunCharConn:Disconnect() end
                    
                    -- 1. Input Listener: Toggle "Pause" when Crouch Key is pressed (Toggle Behavior)
                    autoRunInputConn = uis.InputBegan:Connect(function(input, gpe)
                        if gpe then return end
                        if input.KeyCode == Enum.KeyCode.LeftControl or input.KeyCode == Enum.KeyCode.RightControl or input.KeyCode == Enum.KeyCode.C then
                            isCrouchPaused = not isCrouchPaused
                            lastToggleTime = tick()
                        end
                    end)
                    
                    -- 2. Character Listener: Reset state on respawn
                    -- This fixes the issue where auto run stops working after death
                    autoRunCharConn = players.LocalPlayer.CharacterAdded:Connect(function(newChar)
                        -- Wait for the character to be ready and controllable
                        -- We use task.delay to avoid yielding the main thread if this was in a synchronous context
                        task.delay(0.5, function()
                            if newChar and newChar:FindFirstChild("Humanoid") then
                                isCrouchPaused = false -- Reset to running
                                lastToggleTime = tick()
                                -- Force release momentarily to reset input state for the new character
                                vim:SendKeyEvent(false, Enum.KeyCode.LeftShift, false, game)
                            end
                        end)
                    end)
                    
                    -- 3. Loop: Apply Shift based on state
                    autoRunConn = rs.RenderStepped:Connect(function()
                        if isCrouchPaused then
                            -- Crouching: Force Shift Release
                            vim:SendKeyEvent(false, Enum.KeyCode.LeftShift, false, game)
                        else
                            -- Running: Force Shift Hold
                            -- Small delay after toggling uncrouch to allow animation to start
                            if tick() - lastToggleTime > 0.15 then
                                vim:SendKeyEvent(true, Enum.KeyCode.LeftShift, false, game)
                            else
                                vim:SendKeyEvent(false, Enum.KeyCode.LeftShift, false, game)
                            end
                        end
                    end)
                else
                    if autoRunConn then autoRunConn:Disconnect() end
                    autoRunConn = nil
                    
                    if autoRunInputConn then autoRunInputConn:Disconnect() end
                    autoRunInputConn = nil
                    
                    if autoRunCharConn then autoRunCharConn:Disconnect() end
                    autoRunCharConn = nil
                    
                    vim:SendKeyEvent(false, Enum.KeyCode.LeftShift, false, game)
                end
            end
        })
        autoRunToggle:keybind({
            name = "Auto Run",
            flag = "keybind_auto_run",
            key = nil,
            mode = "toggle",
            default = false,
            callback = function(active)
                autoRunToggle.set(active)
            end
        })
        end
    end


    do
    local camLockToggle = Combat:toggle({name = "Camera Lock", flag = "toggle_camera_lock"})
    camLockToggle:keybind({
        name = "Camera Lock",
        flag = "keybind_camera_lock",
        key = Enum.UserInputType.MouseButton2,
        mode = "hold",
        default = false
    })
    Combat:toggle({name = "Sticky", flag = "toggle_sticky_lock"})
    
    local fovSlider
    local DottedToggle
    local DottedDivider
    local RequiredWeaponToggle
    local fovToggle = Combat:toggle({
        name = "FOV Visible",
        flag = "toggle_fov_circle",
        default = false,
        callback = function(v)
            if v then
                FOVCircle = createDraw("Circle", {
                    Thickness = 0.5,
                    NumSides = 64,
                    Color = FOVColor,
                    Transparency = FOVAlpha,
                    Filled = false,
                    Visible = true
                })
                FOVOutline = createDraw("Circle", {
                    Thickness = 4,
                    NumSides = 64,
                    Color = Color3.fromRGB(0,0,0),
                    Transparency = 0,
                    Filled = false,
                    Visible = true
                })
            else
                if FOVCircle then
                    FOVCircle:Remove()
                    FOVCircle = nil
                end
                if FOVOutline then
                    FOVOutline:Remove()
                    FOVOutline = nil
                end
            end
            if fovSlider then
                fovSlider.set_element_visible(v)
            end
            if DottedToggle then
                DottedToggle.set_element_visible(v)
            end
            if DottedDivider then
                DottedDivider.Visible = v
            end
            if RequiredWeaponToggle then
                RequiredWeaponToggle.set_element_visible(v)
            end
        end
    })
    DottedDivider = library:create("Frame", {
        Parent = Combat.holder,
        Name = "DottedDivider",
        Size = UDim2.new(1, -8, 0, 2),
        BorderSizePixel = 0,
        BackgroundColor3 = Color3.fromRGB(45, 45, 45),
        Visible = false
    })
    -- library:apply_theme(DottedDivider, "accent", "BackgroundColor3")
    RequiredWeaponToggle = Combat:toggle({
        name = "Required Weapon",
        flag = "toggle_required_weapon",
        default = false,
        callback = function(v) end
    })
    RequiredWeaponToggle.set_element_visible(false)
    DottedToggle = Combat:toggle({
        name = "Dotted",
        flag = "toggle_dotted_fov",
        default = false,
        callback = function(v) end
    })
    DottedToggle.set_element_visible(false)
    fovToggle:colorpicker({
        name = "FOV Color",
        flag = "colorpicker_fov_circle",
        color = Color3.fromRGB(255,255,255),
        callback = function(color, alpha)
            FOVColor = color or Color3.fromRGB(255,255,255)
            FOVAlpha = alpha or 1
            if FOVCircle then
                FOVCircle.Color = FOVColor
                FOVCircle.Transparency = FOVAlpha
            end
        end
    })
    fovSlider = Combat:slider({
        name = "FOV Radius",
        flag = "slider_fov",
        suffix = "m",
        min = 5, max = 100, default = 45,
        callback = function(v)
            TargetFOV = v
            if FOVCircle then
                FOVCircle.Radius = v * 5
            end
            if FOVOutline then
                FOVOutline.Radius = (v * 5) + 4
            end
        end
    })
    fovSlider.set_element_visible(false)
    Combat:dropdown({
        name = "Aim Part",
        flag = "dropdown_aim_part",
        items = {"Head", "Torso"},
        default = "Head",
        callback = function(v)
            selectedPart = (v == "Torso") and "UpperTorso" or "Head"
        end
    })
    local divider = library:create("Frame", {
        Parent = Combat.holder,
        Name = "",
        Size = UDim2.new(1, -8, 0, 2),
        BorderSizePixel = 0,
        BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    })
    local silentToggle = Combat:toggle({name = "Silent", flag = "toggle_silent"})
    silentToggle:keybind({
        name = "Silent Aim",
        flag = "keybind_silent_aim",
        mode = "hold",
        key = Enum.UserInputType.MouseButton2,
        default = false
    })
    
    local silentFovSlider
    local dottedSilentFovToggle
    local dottedSilentFovDivider
    local silentFovToggle = Combat:toggle({
        name = "FOV Visible",
        flag = "toggle_fov_circle_silent",
        default = false,
        callback = function(v)
            if v then
                SilentFOVCircle = createDraw("Circle", {
                    Thickness = 0.5,
                    NumSides = 64,
                    Color = SilentFOVColor or Color3.fromRGB(255,255,255),
                    Transparency = SilentFOVAlpha or 1,
                    Filled = false,
                    Visible = true
                })
                SilentFOVOutline = createDraw("Circle", {
                    Thickness = 4,
                    NumSides = 64,
                    Color = Color3.fromRGB(0,0,0),
                    Transparency = 0,
                    Filled = false,
                    Visible = true
                })
            else
                if SilentFOVCircle then
                    SilentFOVCircle:Remove()
                    SilentFOVCircle = nil
                end
                if SilentFOVOutline then
                    SilentFOVOutline:Remove()
                    SilentFOVOutline = nil
                end
            end
            if silentFovSlider then
                silentFovSlider.set_element_visible(v)
            end
            if dottedSilentFovToggle then
                dottedSilentFovToggle.set_element_visible(v)
            end
            if dottedSilentFovDivider then
                dottedSilentFovDivider.Visible = v
            end
        end
    })
    dottedSilentFovDivider = library:create("Frame", {
        Parent = Combat.holder,
        Name = "DottedSilentFOVDivider",
        Size = UDim2.new(1, -8, 0, 2),
        BorderSizePixel = 0,
        BackgroundColor3 = Color3.fromRGB(45, 45, 45),
        Visible = false
    })
    -- library:apply_theme(dottedSilentFovDivider, "accent", "BackgroundColor3")
    dottedSilentFovToggle = Combat:toggle({
        name = "Dotted",
        flag = "toggle_dotted_fov_silent",
        default = false,
        callback = function(v) end
    })
    dottedSilentFovToggle.set_element_visible(false)
    silentFovToggle:colorpicker({
        name = "FOV Color",
        flag = "colorpicker_fov_circle_silent",
        color = Color3.fromRGB(255,255,255),
        callback = function(color, alpha)
            SilentFOVColor = color or Color3.fromRGB(255,255,255)
            SilentFOVAlpha = alpha or 1
            if SilentFOVCircle then
                SilentFOVCircle.Color = SilentFOVColor
                SilentFOVCircle.Transparency = SilentFOVAlpha
            end
        end
    })
    silentFovSlider = Combat:slider({
        name = "FOV Radius",
        flag = "slider_fov_silent",
        suffix = "m",
        min = 5, max = 100, default = 45,
        callback = function(v)
            SilentTargetFOV = v
            if SilentFOVCircle then
                SilentFOVCircle.Radius = v * 5
            end
            if SilentFOVOutline then
                SilentFOVOutline.Radius = (v * 5) + 4
            end
        end
    })
    silentFovSlider.set_element_visible(false)
    end
    Checks:toggle({name = "Knocked", flag = "toggle_death_check", default = true})
    Checks:toggle({name = "Visible", flag = "toggle_raycast", default = true})
    Checks:toggle({name = "Team", flag = "toggle_team_check", default = true})
    Checks:toggle({name = "Friend", flag = "toggle_friend_check"})
    Checks:toggle({name = "ForceField", flag = "toggle_forcefield_check"})

    do
    local triggerbotConn
    local triggerbotFiring = false
    ChecksMisc:toggle({
        name = "Triggerbot",
        flag = "toggle_triggerbot",
        default = false,
        callback = function(v)
            local vim = game:GetService("VirtualInputManager")
            if v then
                if triggerbotConn then triggerbotConn:Disconnect() end
                triggerbotConn = run.RenderStepped:Connect(function()
                    local shouldFire = false
                    local camLockEnabled = library.flags["toggle_camera_lock"]
                    
                    if camLockEnabled and CurrentTarget and CurrentTarget.Character then
                        local hum = CurrentTarget.Character:FindFirstChild("Humanoid")
                        -- Ensure target is alive (not knocked) and valid according to checks
                        if hum and hum.Health > 0 and ValidateTarget(lp, CurrentTarget) then
                            shouldFire = true
                        end
                    end
                    
                    if shouldFire then
                        if not triggerbotFiring then
                            vim:SendMouseButtonEvent(0, 0, 0, true, game, 1)
                            triggerbotFiring = true
                        end
                    else
                        if triggerbotFiring then
                            vim:SendMouseButtonEvent(0, 0, 0, false, game, 1)
                            triggerbotFiring = false
                        end
                    end
                end)
            else
                if triggerbotConn then triggerbotConn:Disconnect() end
                triggerbotConn = nil
                if triggerbotFiring then
                    vim:SendMouseButtonEvent(0, 0, 0, false, game, 1)
                    triggerbotFiring = false
                end
            end
        end
    })
    end


    
    local PlayersService = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local antiVoidToggle -- Forward declaration
    do
    local noclipConn
    local noclipActive = false
    local noclipParts = {}
    local noclipToggle = ChecksMisc:toggle({
        name = "Noclip",
        flag = "toggle_noclip",
        default = false,
        callback = function(v)
            noclipActive = v
            if antiVoidToggle and antiVoidToggle.set_element_visible then
                antiVoidToggle.set_element_visible(v)
            end
            if v then
                if noclipConn then noclipConn:Disconnect() end
                noclipConn = RunService.Stepped:Connect(function()
                    local char = PlayersService.LocalPlayer.Character
                    if noclipActive and char then
                        for _, part in ipairs(char:GetDescendants()) do
                            if part:IsA("BasePart") and part.CanCollide then
                                part.CanCollide = false
                                noclipParts[part] = true
                            end
                        end
                    end
                end)
            else
                if noclipConn then noclipConn:Disconnect() end
                noclipConn = nil
                for p,_ in pairs(noclipParts) do
                    if p and p.Parent then
                        p.CanCollide = true
                    end
                end
                noclipParts = {}
            end
        end
    })
    noclipToggle:keybind({
        name = "Noclip",
        flag = "keybind_noclip",
        key = nil,
        mode = "toggle",
        default = false,
        callback = function(active)
            noclipToggle.set(active)
        end
    })
    end

    do
    local antiVoidConn
    local antiVoidActive = false
    local voidTiles = {}
    local tileSize = Vector3.new(12, 1, 12)
    local antiVoidFloorY = nil
    local catchPlane
    local lastSafeCFrame
    local noGroundTicks = 0
    local voidThresholdY = -200
    antiVoidToggle = ChecksMisc:toggle({
        name = "Anti Void",
        flag = "toggle_anti_void",
        default = false,
        callback = function(v)
            antiVoidActive = v
            if v then
                local player = PlayersService.LocalPlayer
                local hrp
                local function setup(character)
                    hrp = character:WaitForChild("HumanoidRootPart")
                end
                if player.Character then setup(player.Character) end
                player.CharacterAdded:Connect(setup)
                if antiVoidConn then antiVoidConn:Disconnect() end
                antiVoidConn = RunService.Heartbeat:Connect(function()
                    if not antiVoidActive or not hrp then return end
                    local params = RaycastParams.new()
                    params.FilterType = Enum.RaycastFilterType.Blacklist
                    params.FilterDescendantsInstances = {player.Character}
                    local result = workspace:Raycast(hrp.Position, Vector3.new(0, -1000, 0), params)
                    if result then
                        lastSafeCFrame = hrp.CFrame
                        noGroundTicks = 0
                    else
                        noGroundTicks = noGroundTicks + 1
                        local gx = math.floor(hrp.Position.X / tileSize.X)
                        local gz = math.floor(hrp.Position.Z / tileSize.Z)
                        local key = tostring(gx) .. "_" .. tostring(gz)
                        if not antiVoidFloorY then
                            local humanoid = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
                            local hip = humanoid and humanoid.HipHeight or 2
                            antiVoidFloorY = hrp.Position.Y - (hip + 4)
                        end
                        if not voidTiles[key] then
                            local cx = gx * tileSize.X + tileSize.X/2
                            local cz = gz * tileSize.Z + tileSize.Z/2
                            local p = Instance.new("Part")
                            p.Name = "AntiVoidTile"
                            p.Size = tileSize
                            p.Position = Vector3.new(cx, antiVoidFloorY, cz)
                            p.Anchored = true
                            p.CanCollide = true
                            p.Transparency = 1
                            p.Parent = workspace
                            voidTiles[key] = p
                        end
                        if not catchPlane then
                            catchPlane = Instance.new("Part")
                            catchPlane.Name = "AntiVoidFloor"
                            catchPlane.Size = Vector3.new(1000, 1, 1000)
                            local targetY = antiVoidFloorY or math.min(hrp.Position.Y - 10, voidThresholdY)
                            catchPlane.Position = Vector3.new(hrp.Position.X, targetY, hrp.Position.Z)
                            catchPlane.Anchored = true
                            catchPlane.CanCollide = true
                            catchPlane.Transparency = 1
                            catchPlane.Parent = workspace
                            else
                            catchPlane.Position = Vector3.new(hrp.Position.X, catchPlane.Position.Y, hrp.Position.Z)
                        end
                        if hrp.Position.Y < (catchPlane.Position.Y - 5) or hrp.Position.Y < voidThresholdY then
                            hrp.CFrame = CFrame.new(hrp.Position.X, catchPlane.Position.Y + 3, hrp.Position.Z)
                        end
                    end
                end)
            else
                if antiVoidConn then antiVoidConn:Disconnect() end
                antiVoidConn = nil
                antiVoidFloorY = nil
                noGroundTicks = 0
                lastSafeCFrame = nil
                if catchPlane then
                    catchPlane:Destroy()
                    catchPlane = nil
                end
                for _, p in pairs(voidTiles) do
                    p:Destroy()
                end
                voidTiles = {}
            end
        end
    })
    
    -- Hide Anti Void by default
    if antiVoidToggle.set_element_visible then
        antiVoidToggle.set_element_visible(false)
    end
    end

    do
    local spinbotConn
    local spinbotActive = false
    local spinbotSpeed = 20
    
    local spinbotToggle = ChecksMisc:toggle({
        name = "Spinbot",
        flag = "toggle_spinbot",
        default = false,
        callback = function(v)
            spinbotActive = v
            local char = PlayersService.LocalPlayer.Character
            if v then
                if char then
                     local hum = char:FindFirstChild("Humanoid")
                     if hum then hum.AutoRotate = false end
                end
                if spinbotConn then spinbotConn:Disconnect() end
                spinbotConn = RunService.Stepped:Connect(function()
                    local char = PlayersService.LocalPlayer.Character
                    if not char then return end
                    local hrp = char:FindFirstChild("HumanoidRootPart")
                    local hum = char:FindFirstChild("Humanoid")
                    if hum then hum.AutoRotate = false end
                    if hrp then
                        local oldVel = hrp.AssemblyLinearVelocity
                        hrp.CFrame = hrp.CFrame * CFrame.Angles(0, math.rad(spinbotSpeed), 0)
                        hrp.AssemblyLinearVelocity = oldVel
                    end
                end)
            else
                if spinbotConn then spinbotConn:Disconnect() end
                spinbotConn = nil
                if char then
                     local hum = char:FindFirstChild("Humanoid")
                     if hum then hum.AutoRotate = true end
                end
            end
        end
    })
    ChecksMisc:slider({
        name = "Spinbot Speed",
        flag = "spinbot_speed",
        min = -50,
        max = 50,
        default = 20,
        callback = function(v)
            spinbotSpeed = v
        end
    })

    spinbotToggle:keybind({
        name = "Spinbot",
        flag = "keybind_spinbot",
        key = nil,
        mode = "toggle",
        default = false,
        callback = function(active)
            spinbotToggle.set(active)
        end
    })
    -- Set Spinbot text color to red
    if spinbotToggle.text_label then
        spinbotToggle.text_label.TextColor3 = Color3.fromRGB(255, 80, 80)
    end
    end
    
    
    



    
    do
        local toolMaterialType = "Neon"
        local toolMaterialColor = Color3.fromRGB(191, 191, 244)
        local toolMaterialConn
        local toolMaterialDropdown
        local toolEquipConn, backpackAddConn
        local toolCharConn
        local toolDescendantConnMap = {}
        local function disconnectToolDescendants()
            for tool, conn in pairs(toolDescendantConnMap) do
                if conn then conn:Disconnect() end
                toolDescendantConnMap[tool] = nil
            end
        end
        local function applyToolMaterial(tool)
            if not tool then return end
            cacheTool(tool)
            local mat = Enum.Material.Neon
            if toolMaterialType == "ForceField" then
                mat = Enum.Material.ForceField
            end
            for _, part in ipairs(tool:GetDescendants()) do
                if part:IsA("BasePart") then
                    if part.Material ~= mat then part.Material = mat end
                    if part.Color ~= toolMaterialColor then part.Color = toolMaterialColor end
                end
            end
            if not toolDescendantConnMap[tool] then
                toolDescendantConnMap[tool] = tool.DescendantAdded:Connect(function(d)
                    if d:IsA("BasePart") then
                        if d.Material ~= mat then d.Material = mat end
                        if d.Color ~= toolMaterialColor then d.Color = toolMaterialColor end
                    end
                end)
            end
        end
        
        -- Use attributes for caching to survive re-execution
        local function cacheTool(tool)
            for _, part in ipairs(tool:GetDescendants()) do
                if part:IsA("BasePart") then
                    if not part:GetAttribute("TraeOriginalColor") then
                        part:SetAttribute("TraeOriginalColor", part.Color)
                    end
                    if not part:GetAttribute("TraeOriginalMaterial") then
                        part:SetAttribute("TraeOriginalMaterial", part.Material.Name)
                    end
                end
            end
        end



    end
    
    
    do
        local SpeedEnabled = false
        local SpeedAmount = 16
        local SpeedToggle = CharacterMods:toggle({
            name = "Walk Speed",
            flag = "BypassWalkSpeed",
            default = false,
            callback = function(v)
                SpeedEnabled = v
            end
        })
        SpeedToggle:keybind({
            name = "Speed",
            flag = "SpeedKeybind",
            key = nil,
            mode = "toggle",
            default = false,
            callback = function(active)
                SpeedToggle.set(active)
            end
        })

        CharacterMods:slider({
            name = "Speed Amount",
            flag = "SpeedAmount",
            min = 16,
            max = 40,
            default = 40,
            callback = function(v)
                SpeedAmount = v
            end
        })
        game:GetService("RunService").RenderStepped:Connect(function()
            if SpeedEnabled then
                local player = game:GetService("Players").LocalPlayer
                local character = player.Character
                local rootPart
                if character then
                    rootPart = character:FindFirstChild("HumanoidRootPart")
                end
                local humanoid
                if character then
                    humanoid = character:FindFirstChildWhichIsA("Humanoid")
                end
                if rootPart and (humanoid and humanoid.MoveDirection.Magnitude > 0) then
                    local effectiveSpeed = SpeedAmount
                    if library.DesyncData and library.DesyncData.DetectedSCP and library.flags["desync_server"] then
                        effectiveSpeed = math.min(effectiveSpeed, 30)
                    end
                    rootPart.Velocity = humanoid.MoveDirection * effectiveSpeed + Vector3.new(0, rootPart.Velocity.Y, 0)
                end
            end
        end)
    end
    
    do
        local CFrameSpeedEnabled = false
        local CFrameSpeedAmount = 1
        local CFrameSpeedToggle = CharacterMods:toggle({
            name = "CFrame Speed",
            flag = "CFrameSpeedToggle",
            default = false,
            callback = function(v)
                CFrameSpeedEnabled = v
            end
        })
        CFrameSpeedToggle:keybind({
            name = "CFrame Speed",
            flag = "CFrameSpeedKeybind",
            key = nil,
            mode = "toggle",
            default = false,
            callback = function(active)
                CFrameSpeedToggle.set(active)
            end
        })

        CharacterMods:slider({
            name = "CFrame Speed Amount",
            flag = "CFrameSpeedAmount",
            min = 0.1,
            max = 0.17,
            default = 0.15,
            decimal = 0.01,
            callback = function(v)
                CFrameSpeedAmount = v
            end
        })
        
        run.Heartbeat:Connect(function()
            if CFrameSpeedEnabled then
                 local player = players.LocalPlayer
                 local character = player.Character
                 if not character then return end
                 local rootPart = character:FindFirstChild("HumanoidRootPart")
                 local humanoid = character:FindFirstChildOfClass("Humanoid")
                 
                 if rootPart and humanoid and humanoid.MoveDirection.Magnitude > 0 then
                    if library.DesyncData and library.DesyncData.DetectedSCP and library.flags["desync_server"] then
                        -- Disable CFrame Speed logic when SCP detected in desync mode
                    else
                        rootPart.CFrame = rootPart.CFrame + humanoid.MoveDirection * CFrameSpeedAmount
                    end
                 end
            end
        end)
    end
    
    do
        local FlyEnabled = false
        local FlySpeed = 40
        local FlyConnection = nil
        local FlyToggle = CharacterMods:toggle({
            name = "Fly",
            flag = "FlyToggle",
            default = false,
            callback = function(v)
                FlyEnabled = v
                local player = game:GetService("Players").LocalPlayer
                local character = player.Character or player.CharacterAdded:Wait()
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                local uis = game:GetService("UserInputService")
                local camera = workspace.CurrentCamera

                if humanoid and rootPart then
                    if FlyEnabled then
                        FlyConnection = run.Heartbeat:Connect(function()
                            local player = players.LocalPlayer
                            local character = player.Character
                            if not character then return end
                            local rootPart = character:FindFirstChild("HumanoidRootPart")
                            local humanoid = character:FindFirstChildOfClass("Humanoid")
                            local camera = workspace.CurrentCamera
                            
                            if not rootPart or not humanoid then return end

                            local moveDir = Vector3.zero
                            
                            if uis:IsKeyDown(Enum.KeyCode.W) then moveDir = moveDir + camera.CFrame.LookVector end
                            if uis:IsKeyDown(Enum.KeyCode.S) then moveDir = moveDir - camera.CFrame.LookVector end
                            if uis:IsKeyDown(Enum.KeyCode.A) then moveDir = moveDir - camera.CFrame.RightVector end
                            if uis:IsKeyDown(Enum.KeyCode.D) then moveDir = moveDir + camera.CFrame.RightVector end
                            
                            if moveDir.Magnitude > 0 then
                                local effectiveSpeed = FlySpeed
                                if library.DesyncData and library.DesyncData.DetectedSCP and library.flags["desync_server"] then
                                    effectiveSpeed = math.min(effectiveSpeed, 30)
                                end
                                moveDir = moveDir.Unit * effectiveSpeed
                            end
                            
                            rootPart.Velocity = moveDir
                        end)
                    else
                        if FlyConnection then
                            FlyConnection:Disconnect()
                            FlyConnection = nil
                        end
                    end
                end
            end
        })
        FlyToggle:keybind({
            name = "Fly",
            flag = "FlyKeybind",
            key = nil,
            mode = "toggle",
            default = false,
            callback = function(active)
                FlyToggle.set(active)
            end
        })
        CharacterMods:slider({
            name = "Fly Speed",
            flag = "FlySpeed",
            min = 20,
            max = 40,
            default = 40,
            callback = function(v)
                FlySpeed = v
            end
        })
    end
    



    local playersLeft = Players:column()
    local playersRight = Players:column()

    local ESP = playersLeft:section({name = "Extrasensory Perception"})
    
    ESP:toggle({name = "Enabled", flag = "esp_enabled_dummy", default = false, callback = function() end})
    ESP:toggle({name = "Team", flag = "esp_self_dummy", default = false, callback = function() end})

    library:create("Frame", {
        Parent = ESP.holder,
        Name = "Divider",
        Size = UDim2.new(1, -8, 0, 2),
        BackgroundColor3 = Color3.fromRGB(45, 45, 45),
        BorderSizePixel = 0
    })
    
    local box = ESP:toggle({name = "Bounding Boxes", flag = "esp_box_dummy", default = false, callback = function() end})
    box:colorpicker({flag = "esp_box_c1", color = Color3.new(1, 1, 1), callback = function() end})
    box:colorpicker({flag = "esp_box_c2", color = Color3.new(0, 0, 0), callback = function() end})
    
    local cornerBox = ESP:toggle({name = "Corner Boxes", flag = "esp_box_corner_dummy", default = false, callback = function() end})
    cornerBox:colorpicker({flag = "esp_box_corner_c1", color = Color3.new(1, 1, 1), callback = function() end}) -- Optional: Separate color for corners if needed, or reuse box color
    
    local fill = ESP:toggle({name = "Filled Boxes", flag = "esp_fill_dummy", default = false, callback = function() end})
    fill:colorpicker({flag = "esp_fill_c1", color = Color3.new(0, 0, 0), callback = function() end})
    fill:colorpicker({flag = "esp_fill_c2", color = Color3.fromRGB(100, 100, 255), callback = function() end})
    
    local tracerPosDropdown
    local tracer = ESP:toggle({name = "Tracer", flag = "esp_tracer_dummy", default = false, callback = function(v)
        if tracerPosDropdown and tracerPosDropdown.set_element_visible then
            tracerPosDropdown.set_element_visible(v)
        end
    end})
    tracer:colorpicker({flag = "esp_tracer_c1", color = Color3.fromRGB(100, 100, 255), callback = function() end})
    
    tracerPosDropdown = ESP:dropdown({name = "Tracer Position", flag = "esp_tracer_pos_dummy", items = {"Bottom", "Top", "Mouse"}, default = "Bottom", callback = function() end})
    if tracerPosDropdown.set_element_visible then
        tracerPosDropdown.set_element_visible(false)
    end
    
    library:create("Frame", {
        Parent = ESP.holder,
        Name = "Divider",
        Size = UDim2.new(1, -8, 0, 2),
        BackgroundColor3 = Color3.fromRGB(45, 45, 45),
        BorderSizePixel = 0
    })

    local scpOptionsDropdown
    local scpChams = ESP:toggle({name = "niggaESP!!!!>.<", flag = "scp_chams_toggle", default = false, callback = function(v)
        if scpOptionsDropdown and scpOptionsDropdown.set_element_visible then
            scpOptionsDropdown.set_element_visible(v)
        end
    end})
    scpChams:colorpicker({flag = "scp_chams_fill_color", color = Color3.fromRGB(218, 81, 157), callback = function() end})
    scpChams:colorpicker({flag = "scp_chams_outline_color", color = Color3.new(0, 0, 0), callback = function() end})

    scpOptionsDropdown = ESP:dropdown({name = "Visual Options", flag = "scp_options_dummy", items = {"ForceSee (NOT DONE)", "ForceThermal"}, multi = true, default = {}, callback = function() end})
    if scpOptionsDropdown.set_element_visible then
        scpOptionsDropdown.set_element_visible(false)
    end
    ESP:toggle({name = "Name", flag = "scp_name_toggle", default = false, callback = function() end})
    ESP:toggle({name = "Distance", flag = "scp_distance_toggle", default = false, callback = function() end})

    library:create("Frame", {
        Parent = ESP.holder,
        Name = "Divider",
        Size = UDim2.new(1, -8, 0, 2),
        BackgroundColor3 = Color3.fromRGB(45, 45, 45),
        BorderSizePixel = 0
    })

    local chams = ESP:toggle({name = "Chams", flag = "esp_chams_dummy", default = false, callback = function() end})
    chams:colorpicker({flag = "esp_chams_c1", color = Color3.fromRGB(100, 100, 255), callback = function() end})
    chams:colorpicker({flag = "esp_chams_c2", color = Color3.new(0, 0, 0), callback = function() end})
    
    local healthNum = ESP:toggle({name = "Health Text", flag = "esp_health_num_dummy", default = false, callback = function() end})
    healthNum:colorpicker({flag = "esp_health_num_c1", color = Color3.new(1,1,1), callback = function() end})
    
    local healthBar = ESP:toggle({name = "Health Bars", flag = "esp_health_bar_dummy", default = false, callback = function() end})
    healthBar:colorpicker({flag = "esp_health_bar_c1", color = Color3.new(0,1,0), callback = function() end})
    healthBar:colorpicker({flag = "esp_health_bar_c2", color = Color3.new(1,0,0), callback = function() end})
    
    ESP:slider({name = "Width", flag = "esp_width_dummy", min = 1, max = 10, default = 1, callback = function() end})
    
    local name = ESP:toggle({name = "Names", flag = "esp_name_dummy", default = false, callback = function() end})
    name:colorpicker({flag = "esp_name_c1", color = Color3.new(1,1,1), callback = function() end})
    
    ESP:toggle({name = "Use Display", flag = "esp_use_display_dummy", default = false, callback = function() end})
    
    ESP:slider({name = "Font Size", flag = "esp_font_size_dummy", min = 10, max = 30, default = 10, callback = function() end})
    
    local distance = ESP:toggle({name = "Distance", flag = "esp_distance_dummy", default = false, callback = function() end})
    distance:colorpicker({flag = "esp_distance_c1", color = Color3.new(1,1,1), callback = function() end})
    
    local weapon = ESP:toggle({name = "Weapons", flag = "esp_weapon_dummy", default = false, callback = function() end})
    weapon:colorpicker({flag = "esp_weapon_c1", color = Color3.new(1,1,1), callback = function() end})

    local Settings = playersRight:section({name = "Settings"})
    
    Settings:toggle({name = "Animated Boxes", flag = "esp_box_animate", default = false, callback = function() end})
    Settings:toggle({name = "Dynamic Health Text", flag = "esp_health_dynamic", default = false, callback = function() end})
    Settings:toggle({name = "Gradient Health Bar", flag = "esp_health_gradient", default = false, callback = function() end})
    local gradAnim = Settings:toggle({name = "Thermal chams", flag = "esp_chams_thermal", default = false, callback = function() end})

    library:create("Frame", {
        Parent = Settings.holder,
        Name = "Divider",
        Size = UDim2.new(1, -8, 0, 2),
        BackgroundColor3 = Color3.fromRGB(45, 45, 45),
        BorderSizePixel = 0
    })

    Settings:dropdown({name = "Text Font", flag = "settings_font_dummy", items = {"Minecraft", "Plex", "System"}, default = "Minecraft", callback = function() end})
    Settings:slider({name = "Max Render Distance", flag = "settings_max_dist_dummy", min = 10, max = 5000, default = 1000, suffix = "", callback = function() end})

    -- Visuals Tab
    ;(function()
        local visualsLeft = Visuals:column()
        local visualsRight = Visuals:column()

        do -- Left Column: Player
            local PlayerSection = visualsLeft:section({name = "Player"})
            
            -- Wind Aura Logic
            local visualsAuraColor1 = Color3.fromRGB(191, 191, 244)
            local currentVisualsAuraAttachment = nil
            local visualsAuraConn = nil
            local lastVisualsAuraUpdate = 0

            local function createWindAura(char)
                if not char then return end
                local target = char:FindFirstChild("HumanoidRootPart")
                if not target then return end
                
                if target:FindFirstChild("TraeVisualsAuraAttachment") then return end

                local attachment = Instance.new("Attachment")
                attachment.Name = "TraeVisualsAuraAttachment"
                attachment.Position = Vector3.new(0, 0, 0) 
                attachment.Parent = target
                
                -- Wind Aura Logic (Angel Wings)
                attachment.CFrame = attachment.CFrame * CFrame.new(0, 0, 0, 0.965, 0.259, 0, -0.259, 0.965, 0, 0, 0, 1)
                attachment.Axis = Vector3.new(0.966, -0.259, 0)
                attachment.SecondaryAxis = Vector3.new(0.259, 0.966, 0)
                
                local particleEmitter = Instance.new("ParticleEmitter")
                particleEmitter.Name = "ParticleEmitter"
                particleEmitter.Texture = "rbxassetid://14054635072"
                particleEmitter.LockedToPart = true
                particleEmitter.Brightness = 1
                particleEmitter.LightEmission = 1
                particleEmitter.LightInfluence = 0
                particleEmitter.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
                particleEmitter.Size = NumberSequence.new(4)
                particleEmitter.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.5, 0), NumberSequenceKeypoint.new(1, 1)})
                particleEmitter.Lifetime = NumberRange.new(1)
                particleEmitter.Rate = 10
                particleEmitter.Rotation = NumberRange.new(0, 360)
                particleEmitter.RotSpeed = NumberRange.new(30, 60)
                particleEmitter.Speed = NumberRange.new(0.01)
                particleEmitter.SpreadAngle = Vector2.new(0.1)
                particleEmitter.Color = ColorSequence.new(visualsAuraColor1)
                particleEmitter.Parent = attachment
                
                currentVisualsAuraAttachment = attachment
            end

            local function removeVisualsAura()
                if currentVisualsAuraAttachment then
                    currentVisualsAuraAttachment:Destroy()
                    currentVisualsAuraAttachment = nil
                end
                local char = PlayersService.LocalPlayer.Character
                if char then
                    for _, v in ipairs(char:GetDescendants()) do
                        if v.Name == "TraeVisualsAuraAttachment" then
                            v:Destroy()
                        end
                    end
                end
            end

            local function visualsAuraUpdate()
                -- Check for style
                local currentStyles = flags.visuals_aura_style or {}
                if type(currentStyles) ~= "table" then currentStyles = {currentStyles} end
                
                local hasWind = false
                for _, s in ipairs(currentStyles) do
                    if s == "Wind" then hasWind = true break end
                end

                if not hasWind then
                    removeVisualsAura()
                    return
                end

                local now = tick()
                if now - lastVisualsAuraUpdate < (1/30) then return end
                lastVisualsAuraUpdate = now
                local char = PlayersService.LocalPlayer.Character
                if char then
                    local target = char:FindFirstChild("HumanoidRootPart")
                    if target then
                        local att = target:FindFirstChild("TraeVisualsAuraAttachment")
                        if not att then
                            createWindAura(char)
                        else
                            local cam = workspace.CurrentCamera
                            if cam then
                                local _, yRot, _ = cam.CFrame:ToEulerAnglesYXZ()
                                local tiltCFrame = CFrame.new(0, 0, 0, 0.965, 0.259, 0, -0.259, 0.965, 0, 0, 0, 1)
                                att.WorldCFrame = CFrame.new(target.Position) * CFrame.Angles(0, yRot, 0) * tiltCFrame
                            end
                            local emitter = att:FindFirstChild("ParticleEmitter")
                            if emitter then
                                emitter.Color = ColorSequence.new(visualsAuraColor1)
                            end
                        end
                    end
                end
            end

            do
                local aura = PlayerSection:toggle({name = "Aura", flag = "visuals_aura", default = false, callback = function(v)
                    if v then
                        if visualsAuraConn then visualsAuraConn:Disconnect() end
                        visualsAuraConn = RunService.RenderStepped:Connect(visualsAuraUpdate)
                    else
                        if visualsAuraConn then visualsAuraConn:Disconnect() end
                        visualsAuraConn = nil
                        removeVisualsAura()
                    end
                end})
                aura:colorpicker({flag = "visuals_aura_color1", color = Color3.fromRGB(191, 191, 244), callback = function(c) visualsAuraColor1 = c end})
            end
            
            PlayerSection:dropdown({
                name = "Style", 
                flag = "visuals_aura_style", 
                items = {"Wind"}, 
                default = {"Wind"},
                multi = true,
                callback = function(v)
                    -- If aura is active, force an update check immediately
                    if flags.visuals_aura and visualsAuraUpdate then
                        -- visualsAuraUpdate runs on renderstepped, but we can check logic here if needed
                        -- Actually, the renderstepped loop will handle it next frame.
                        -- If we just deselected Wind, we want it to vanish immediately?
                        -- visualsAuraUpdate() checks flags, so it should be fine.
                        -- However, if we are paused or something? No, RenderStepped is continuous.
                        -- But we can call it once to be responsive.
                        visualsAuraUpdate()
                    end
                end
            })

            -- Self Material
            do
                local PlayersService = game:GetService("Players")
                local selfMaterialColor = Color3.fromRGB(191, 191, 244)
                local selfMaterialConn
                local selfMaterialRespawnConn
                local selfMaterialLoop = nil -- Loop for brute-forcing color
                local selfMaterialParts = {}
                local lastSelfMaterialColor = nil
                local cachedBodyColors = nil
                
                local function collectSelfMaterialParts(char)
                    table.clear(selfMaterialParts)
                    if not char then return end
                    for _, part in ipairs(char:GetDescendants()) do
                        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" and not part:FindFirstAncestorOfClass("Tool") then
                            table.insert(selfMaterialParts, part)
                        end
                    end
                end

                local function applySelfMaterialOnce()
                    for _, part in ipairs(selfMaterialParts) do
                        if part and part.Parent then
                            if part.Material ~= Enum.Material.ForceField then
                                part.Material = Enum.Material.ForceField
                            end
                            if part.Color ~= selfMaterialColor then
                                part.Color = selfMaterialColor
                            end
                        end
                    end
                end

                local function enableForCharacter(char)
                    if not char then return end
                    if selfMaterialConn then selfMaterialConn:Disconnect() end
                    
                    -- Handle BodyColors to prevent interference
                    local bc = char:FindFirstChildWhichIsA("BodyColors")
                    if bc then
                        cachedBodyColors = bc:Clone()
                        bc:Destroy()
                    end
                    
                    collectSelfMaterialParts(char)
                    applySelfMaterialOnce()
                    
                    selfMaterialConn = char.DescendantAdded:Connect(function(d)
                        if d:IsA("BasePart") and d.Name ~= "HumanoidRootPart" and not d:FindFirstAncestorOfClass("Tool") then
                            table.insert(selfMaterialParts, d)
                            if d.Material ~= Enum.Material.ForceField then
                                d.Material = Enum.Material.ForceField
                            end
                            d.Color = selfMaterialColor
                        elseif d:IsA("BodyColors") then
                            -- If BodyColors is added later (e.g. by server), destroy it to keep our color
                            if not cachedBodyColors then cachedBodyColors = d:Clone() end
                            d:Destroy() -- Destroy immediately, loop handles application
                        end
                    end)
                end



                local selfMaterialToggle = PlayerSection:toggle({
                    name = "Self Material",
                    flag = "toggle_self_material",
                    default = false,
                    callback = function(v)
                        if v then
                            local char = PlayersService.LocalPlayer.Character
                            if char then enableForCharacter(char) end
                            
                            if selfMaterialRespawnConn then selfMaterialRespawnConn:Disconnect() end
                            selfMaterialRespawnConn = PlayersService.LocalPlayer.CharacterAdded:Connect(function(newChar)
                                cachedBodyColors = nil -- Reset for new character
                                -- Wait for character to load fully
                                local root = newChar:WaitForChild("HumanoidRootPart", 10)
                                local head = newChar:WaitForChild("Head", 10)
                                if root and head then
                                    enableForCharacter(newChar)
                                end
                            end)

                            if selfMaterialLoop then selfMaterialLoop:Disconnect() end
                            selfMaterialLoop = RunService.RenderStepped:Connect(function()
                                applySelfMaterialOnce()
                            end)
                        else
                            if selfMaterialLoop then selfMaterialLoop:Disconnect() end
                            selfMaterialLoop = nil
                            if selfMaterialRespawnConn then selfMaterialRespawnConn:Disconnect() end
                            selfMaterialRespawnConn = nil
                            if selfMaterialConn then selfMaterialConn:Disconnect() end
                            selfMaterialConn = nil
                            
                            -- Revert logic
                            local char = PlayersService.LocalPlayer.Character
                            if char then
                                -- Restore BodyColors first
                                if cachedBodyColors then
                                    cachedBodyColors.Parent = char
                                    cachedBodyColors = nil
                                end
                                
                                for _, part in ipairs(char:GetDescendants()) do
                                    if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" and not part:FindFirstAncestorOfClass("Tool") then
                                        part.Material = Enum.Material.Plastic
                                        part.Color = Color3.fromRGB(255, 255, 255) -- Reset color base
                                        
                                        -- Try to restore body colors if available
                                        local bodyColors = char:FindFirstChildWhichIsA("BodyColors")
                                        if bodyColors then
                                            if part.Name == "Head" then
                                                part.Color = bodyColors.HeadColor3
                                            elseif part.Name == "LeftArm" or part.Name == "LeftUpperArm" or part.Name == "LeftLowerArm" or part.Name == "LeftHand" then
                                                part.Color = bodyColors.LeftArmColor3
                                            elseif part.Name == "RightArm" or part.Name == "RightUpperArm" or part.Name == "RightLowerArm" or part.Name == "RightHand" then
                                                part.Color = bodyColors.RightArmColor3
                                            elseif part.Name == "LeftLeg" or part.Name == "LeftUpperLeg" or part.Name == "LeftLowerLeg" or part.Name == "LeftFoot" then
                                                part.Color = bodyColors.LeftLegColor3
                                            elseif part.Name == "RightLeg" or part.Name == "RightUpperLeg" or part.Name == "RightLowerLeg" or part.Name == "RightFoot" then
                                                part.Color = bodyColors.RightLegColor3
                                            elseif part.Name == "Torso" or part.Name == "UpperTorso" or part.Name == "LowerTorso" then
                                                part.Color = bodyColors.TorsoColor3
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                })
                selfMaterialToggle:colorpicker({
                    name = "Material Color",
                    flag = "colorpicker_self_material",
                    color = Color3.fromRGB(191, 191, 244),
                    callback = function(color)
                        selfMaterialColor = color
                        -- Lightweight color apply only when toggle is ON and color changed
                        if library.flags and library.flags["toggle_self_material"] then
                            if (not lastSelfMaterialColor) or lastSelfMaterialColor ~= selfMaterialColor then
                                lastSelfMaterialColor = selfMaterialColor
                                for _, part in ipairs(selfMaterialParts) do
                                    if part and part.Parent then
                                        part.Color = selfMaterialColor
                                    end
                                end
                            end
                        end
                    end
                })
            end

            -- Self Tool Material
            do
                local toolMaterialType = "Neon"
                local toolMaterialColor = Color3.fromRGB(191, 191, 244)
                local toolMaterialConn
                local toolMaterialDropdown
                local toolEquipConn, backpackAddConn
                local toolCharConn
                local toolDescendantConnMap = {}
                local function disconnectToolDescendants()
                    for tool, conn in pairs(toolDescendantConnMap) do
                        if conn then conn:Disconnect() end
                        toolDescendantConnMap[tool] = nil
                    end
                end
                local function applyToolMaterial(tool)
                    if not tool then return end
                    cacheTool(tool)
                    local mat = Enum.Material.Neon
                    if toolMaterialType == "ForceField" then
                        mat = Enum.Material.ForceField
                    end
                    for _, part in ipairs(tool:GetDescendants()) do
                        if part:IsA("BasePart") then
                            if part.Material ~= mat then part.Material = mat end
                            if part.Color ~= toolMaterialColor then part.Color = toolMaterialColor end
                        end
                    end
                    if not toolDescendantConnMap[tool] then
                        toolDescendantConnMap[tool] = tool.DescendantAdded:Connect(function(d)
                            if d:IsA("BasePart") then
                                if d.Material ~= mat then d.Material = mat end
                                if d.Color ~= toolMaterialColor then d.Color = toolMaterialColor end
                            end
                        end)
                    end
                end
                
                -- Use attributes for caching to survive re-execution
                local function cacheTool(tool)
                    for _, part in ipairs(tool:GetDescendants()) do
                        if part:IsA("BasePart") then
                            if not part:GetAttribute("TraeOriginalColor") then
                                part:SetAttribute("TraeOriginalColor", part.Color)
                            end
                            if not part:GetAttribute("TraeOriginalMaterial") then
                                part:SetAttribute("TraeOriginalMaterial", part.Material.Name)
                            end
                        end
                    end
                end

                local selfToolMaterialToggle = PlayerSection:toggle({
                    name = "Self Tool Material",
                    flag = "toggle_self_tool_material",
                    default = false,
                    callback = function(v)
                        if toolMaterialDropdown then
                            toolMaterialDropdown.set_element_visible(v)
                        end
                        
                        if v then
                            if toolEquipConn then toolEquipConn:Disconnect() end
                            toolEquipConn = nil
                            if backpackAddConn then backpackAddConn:Disconnect() end
                            backpackAddConn = nil
                            if toolCharConn then toolCharConn:Disconnect() end
                            toolCharConn = nil
                            if toolMaterialConn then toolMaterialConn:Disconnect() end
                            toolMaterialConn = RunService.RenderStepped:Connect(function()
                                local char = PlayersService.LocalPlayer.Character
                                if char then
                                    local tool = char:FindFirstChildOfClass("Tool")
                                    if tool then
                                        cacheTool(tool)
                                        local mat = Enum.Material.Neon
                                        if toolMaterialType == "ForceField" then
                                            mat = Enum.Material.ForceField
                                        end
                                        for _, part in ipairs(tool:GetDescendants()) do
                                            if part:IsA("BasePart") then
                                                part.Material = mat
                                                part.Color = toolMaterialColor
                                            end
                                        end
                                    end
                                end
                            end)
                        else
                            if toolMaterialConn then toolMaterialConn:Disconnect() end
                            toolMaterialConn = nil
                            if toolEquipConn then toolEquipConn:Disconnect() end
                            toolEquipConn = nil
                            if backpackAddConn then backpackAddConn:Disconnect() end
                            backpackAddConn = nil
                            if toolCharConn then toolCharConn:Disconnect() end
                            toolCharConn = nil
                            
                            local function revertTool(tool)
                                if tool then
                                    for _, part in ipairs(tool:GetDescendants()) do
                                        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                                            -- Try to restore from attributes
                                            local origColor = part:GetAttribute("TraeOriginalColor")
                                            local origMat = part:GetAttribute("TraeOriginalMaterial")
                                            
                                            if origMat then
                                                part.Material = Enum.Material[origMat] or Enum.Material.Plastic
                                                -- Do not clear attribute to preserve original state memory
                                            else
                                                part.Material = Enum.Material.Plastic
                                            end
                                            
                                            if origColor then
                                                part.Color = origColor
                                                -- Do not clear attribute to preserve original state memory
                                            else
                                                -- Fallback: if it looks like our custom color, reset to white
                                                -- Use fuzzy comparison to handle float precision
                                                local r_diff = math.abs(part.Color.R - toolMaterialColor.R)
                                                local g_diff = math.abs(part.Color.G - toolMaterialColor.G)
                                                local b_diff = math.abs(part.Color.B - toolMaterialColor.B)
                                                
                                                if r_diff < 0.01 and g_diff < 0.01 and b_diff < 0.01 then
                                                    part.Color = Color3.new(1, 1, 1)
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                            
                            local char = PlayersService.LocalPlayer.Character
                            if char then
                                for _, child in ipairs(char:GetChildren()) do
                                    if child:IsA("Tool") then
                                        revertTool(child)
                                    end
                                end
                            end
                            
                            local backpack = PlayersService.LocalPlayer:FindFirstChild("Backpack")
                            if backpack then
                                for _, child in ipairs(backpack:GetChildren()) do
                                    if child:IsA("Tool") then
                                        revertTool(child)
                                    end
                                end
                            end
                        end
                    end
                })

                toolMaterialDropdown = PlayerSection:dropdown({
                    name = "Material Type",
                    flag = "dropdown_tool_material_type",
                    items = {"Neon", "ForceField"},
                    default = "Neon",
                    callback = function(v)
                        toolMaterialType = v
                    end
                })
                
                if toolMaterialDropdown then
                    toolMaterialDropdown.set_element_visible(false)
                end
                
                selfToolMaterialToggle:colorpicker({
                     name = "Tool Color",
                     flag = "colorpicker_tool_material",
                     color = Color3.fromRGB(191, 191, 244),
                     callback = function(color)
                         toolMaterialColor = color
                     end
                })
            end

            -- Trail Logic
            do
                local trailEnabled = false
                local trailColor1 = Color3.fromRGB(191, 191, 244)
                local trailColor2 = Color3.fromRGB(191, 191, 244)
                local trailLifetime = 2.3

                local function updateTrailColor()
                     local char = PlayersService.LocalPlayer.Character
                     if not char then return end
                     local root = char:FindFirstChild("HumanoidRootPart")
                     if not root then return end
                     local trail = root:FindFirstChild("TraeTrail")
                     if trail then
                         trail.Color = ColorSequence.new(trailColor1, trailColor2)
                     end
                end

                local function updateTrail(state)
                    local char = PlayersService.LocalPlayer.Character
                    if not char then return end
                    local root = char:FindFirstChild("HumanoidRootPart")
                    if not root then return end

                    if state then
                        if not root:FindFirstChild("TraeTrail") then
                            local trail = Instance.new("Trail")
                            trail.Name = "TraeTrail"
                            trail.Parent = root

                            local att0 = Instance.new("Attachment", root)
                            att0.Name = "TraeTrailAtt0"
                            att0.Position = Vector3.new(0, 1, 0)

                            local att1 = Instance.new("Attachment", root)
                            att1.Name = "TraeTrailAtt1"
                            att1.Position = Vector3.new(0, -1, 0)

                            trail.Attachment0 = att0
                            trail.Attachment1 = att1
                            trail.Color = ColorSequence.new(trailColor1, trailColor2)
                            trail.Lifetime = trailLifetime
                            trail.Transparency = NumberSequence.new(0, 0)
                            trail.LightEmission = 0.2
                            trail.Brightness = 10
                            trail.WidthScale = NumberSequence.new{
                                NumberSequenceKeypoint.new(0, 0.1),
                                NumberSequenceKeypoint.new(1, 0)
                            }
                        else
                             updateTrailColor()
                        end
                    else
                        local trail = root:FindFirstChild("TraeTrail")
                        if trail then trail:Destroy() end
                        local att0 = root:FindFirstChild("TraeTrailAtt0")
                        if att0 then att0:Destroy() end
                        local att1 = root:FindFirstChild("TraeTrailAtt1")
                        if att1 then att1:Destroy() end
                    end
                end

                local trailRespawnConn

                local trailToggle = PlayerSection:toggle({
                    name = "Trail",
                    flag = "toggle_trail",
                    default = false,
                    callback = function(v)
                        trailEnabled = v
                        updateTrail(v)

                        if v then
                            if trailRespawnConn then trailRespawnConn:Disconnect() end
                            trailRespawnConn = PlayersService.LocalPlayer.CharacterAdded:Connect(function(newChar)
                                newChar:WaitForChild("HumanoidRootPart")
                                if trailEnabled then
                                    updateTrail(true)
                                end
                            end)
                        else
                            if trailRespawnConn then trailRespawnConn:Disconnect() end
                            trailRespawnConn = nil
                        end
                    end
                })

                trailToggle:colorpicker({
                    name = "Trail Color 1",
                    flag = "color_trail_1",
                    color = trailColor1,
                    callback = function(v)
                        trailColor1 = v
                        if trailEnabled then
                            updateTrailColor()
                        end
                    end
                })

                trailToggle:colorpicker({
                    name = "Trail Color 2",
                    flag = "color_trail_2",
                    color = trailColor2,
                    callback = function(v)
                        trailColor2 = v
                        if trailEnabled then
                            updateTrailColor()
                        end
                    end
                })
            end
        end

        do -- Left Column: See Through
            local SeeThroughSection = visualsLeft:section({name = "FlowState >.<"})
            
            -- [[ seethrough.txt Logic ]]
            local stLibrary = {
                enabled = true;
                box = {
                    enabled = false;
                    outline = true;
                    colors = {
                        inline = Color3.fromRGB(255, 255, 255);
                        outline = Color3.fromRGB(0, 0, 0);
                    };
                    fill = {
                        enabled = true;
                        transparency = 0.8;
                        color = Color3.fromRGB(255, 255, 255);
                    }
                };
                chams = {
                    enabled = true;
                    visible = true;
                    occluded = true;
                    colors = {
                        visible = Color3.fromRGB(0, 0, 0);
                        occluded = Color3.fromRGB(255, 255, 255);
                    };
                    transparency = {
                        visible = 0.5;
                        occluded = 0;
                    };
                };
            };

            local functions = {}; do
                -- Polyfill gethui if missing
                local gethui = gethui or function() return game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui") end

                function functions:create(element, properties)
                    local inst = typeof(element) == 'string' and Instance.new(element) or element
                    for property, v in pairs(properties) do
                        inst[property] = v
                    end;
                    return inst
                end;

                function functions:clone(part, model)
                    if (not part:IsA("BasePart")) then return end;

                    local clone = part:Clone()
                    for _, v in ipairs(clone:GetChildren()) do
                        if (not v:IsA("SpecialMesh")) then
                            v:Destroy()
                        else
                            v.TextureId = ""
                        end
                    end
                    clone.Size = clone.Size * 0.9
                    clone.CanCollide = false
                    clone.CanTouch = false
                    clone.CanQuery = false
                    clone.CastShadow = false
                    clone.Anchored = true
                    clone.Parent = model
                    return clone
                end;
            end;
            
            local esp = {}; do 
                esp.add = function(plr)
                    if (esp[plr]) then return end;

                    local player_gui = functions:create("ScreenGui", {
                        Name = "/.";
                        Parent = gethui();
                        DisplayOrder = -1;
                        IgnoreGuiInset = true;
                    });

                    local model = functions:create("Model", {
                        Name = plr.Name;
                        Parent = workspace;
                    });

                    local always_on_top = functions:create("Highlight", {
                        Name = "AlwaysOnTop";
                        DepthMode = Enum.HighlightDepthMode.Occluded;
                        OutlineColor = Color3.fromRGB(0, 0, 0);
                        OutlineTransparency = 1;
                        Parent = plr.Character;
                    });

                    local occluded = functions:create("Highlight", {
                        Name = "Occluded";
                        DepthMode = Enum.HighlightDepthMode.AlwaysOnTop;
                        OutlineColor = Color3.fromRGB(0, 0, 0);
                        OutlineTransparency = 1;
                        Parent = model;
                    });

                    local holder = functions:create("Frame", {
                        Name = "Outer";
                        Parent = player_gui;
                        BackgroundTransparency = 1;
                        BorderSizePixel = 0;
                    })

                    local fill = functions:create("Frame", {
                        Name = "Inner";
                        Parent = holder;
                        BackgroundTransparency = 1;
                        BorderSizePixel = 0;
                    });

                    local outline = functions:create("UIStroke", {
                        Enabled = false;
                        ApplyStrokeMode = Enum.ApplyStrokeMode.Border;
                        LineJoinMode = Enum.LineJoinMode.Miter;
                        Thickness = 3;
                    });

                    local inline = functions:create("UIStroke", {
                        Enabled = false;
                        ApplyStrokeMode = Enum.ApplyStrokeMode.Border;
                        LineJoinMode = Enum.LineJoinMode.Miter;
                        Thickness = 1;
                    });

                    esp[plr] = {
                        chams = {
                            model = model;
                            always_on_top = always_on_top;
                            occluded = occluded;
                            clones = {};
                        };
                        box = {
                            holder = holder;
                            fill = fill;
                            inline = inline;
                            outline = outline;
                        };
                        connection = nil;
                    };

                    local elements = esp[plr];

                    for _, v in ipairs(plr.Character:GetChildren()) do
                        if( v:IsA("BasePart") or v:IsA("Accessory") or v:IsA("Hat")) then
                            if (v:IsA("Accessory") and v:FindFirstChild("Handle") or v) then
                                local clone = functions:clone(v:IsA("Accessory") and v:FindFirstChild("Handle") or v, model)
                                if (clone) then
                                    esp[plr].chams.clones[v:IsA("Accessory") and v:FindFirstChild("Handle") or v] = clone
                                end;
                            end;
                        end;
                    end;
                    
                    -- Listen for new children (limbs/accessories loading in)
                    esp[plr].childAdded = plr.Character.ChildAdded:Connect(function(v)
                         if( v:IsA("BasePart") or v:IsA("Accessory") or v:IsA("Hat")) then
                            if (v:IsA("Accessory") and v:FindFirstChild("Handle") or v) then
                                local clone = functions:clone(v:IsA("Accessory") and v:FindFirstChild("Handle") or v, model)
                                if (clone) then
                                    esp[plr].chams.clones[v:IsA("Accessory") and v:FindFirstChild("Handle") or v] = clone
                                end;
                            end;
                        end;
                    end)

                    esp.update = function()
                        if esp[plr].connection then esp[plr].connection:Disconnect() end
                        
                        esp[plr].connection = run.Heartbeat:Connect(function()
                            local character = plr.Character
                            local root_part = character and character:FindFirstChild("HumanoidRootPart")
                            local humanoid = character and character:FindFirstChild("Humanoid")

                            if (character and root_part and humanoid.Health > 0) then
                                local position, on_screen = camera:WorldToViewportPoint(root_part.Position)

                                local occluded = elements.chams.occluded
                                local always_on_top = elements.chams.always_on_top
                                local model = elements.chams.model
                                local clones = elements.chams.clones

                                local holder = elements.box.holder;
                                local fill = elements.box.fill;
                                local outline = elements.box.outline;
                                local inline = elements.box.inline;

                                -- box math
                                local theta = math.rad(camera.FieldOfView);
                                local d = 2 * position.Z * math.tan(theta / 2);
                                local scale = (root_part.Size.Y * camera.ViewportSize.Y) / (d * 1.5);
                                local height, width = 4.5 * scale,  3 * scale

                                if (on_screen) then 
                                    do -- bounding box
                                        if (stLibrary.box.enabled) then
                                            holder.Visible = true;
                                            holder.Position = UDim2.new(0, position.X - width / 2, 0, position.Y - height / 2.3);
                                            holder.Size = UDim2.new(0, width, 0, height);
                                            holder.BackgroundTransparency = stLibrary.box.fill.enabled and stLibrary.box.fill.transparency or 1

                                            fill.Visible = true;
                                            fill.Parent = holder;
                                            fill.Position = UDim2.new(0, -1,0, -1);
                                            fill.Size = UDim2.new(1, 2, 1, 2);
                                            fill.BackgroundColor3 = stLibrary.box.fill.color;
                                            fill.BackgroundTransparency = 1

                                            inline.Enabled = stLibrary.box.enabled;
                                            inline.Parent = fill;
                                            inline.Color = stLibrary.box.colors.inline or Color3.fromRGB(255, 255, 255);
                                            inline.Transparency = 0;

                                            outline.Enabled = stLibrary.box.enabled and stLibrary.box.outline or true;
                                            outline.Parent = holder;
                                            outline.Color = stLibrary.box.colors.outline or Color3.fromRGB(0, 0, 0);
                                            outline.Transparency = 0;
                                        else
                                            inline.Enabled = false;
                                            outline.Enabled = false;
                                            holder.Visible = false
                                        end;
                                    end;

                                    do -- chams
                                        if (stLibrary.chams.enabled) then
                                            model.Parent = workspace

                                            occluded.Enabled = stLibrary.chams.occluded;
                                            occluded.FillColor = stLibrary.chams.colors.occluded;
                                            occluded.FillTransparency = stLibrary.chams.transparency.occluded;

                                            always_on_top.Enabled = stLibrary.chams.visible;
                                            always_on_top.FillColor = stLibrary.chams.colors.visible;
                                            always_on_top.FillTransparency = stLibrary.chams.transparency.visible;

                                            for i, v in pairs(clones) do
                                                if (i and v) then
                                                    v.Position = i.Position
                                                    v.Orientation = i.Orientation
                                                end
                                            end
                                        else
                                            model.Parent = nil
                                            occluded.Enabled = false
                                            always_on_top.Enabled = false
                                        end
                                    end;
                                else
                                    model.Parent = nil
                                    occluded.Enabled = false
                                    always_on_top.Enabled = false
                                    holder.Visible = false
                                end;
                            else
                                esp.remove(plr)
                            end;
                        end);
                    end;

                    esp.update()
                end;

                esp.remove = function(plr)
                    if (not esp[plr]) then return end
                    
                    if esp[plr].connection then esp[plr].connection:Disconnect() end
                    if esp[plr].childAdded then esp[plr].childAdded:Disconnect() end

                    for _, obj in pairs(esp[plr].chams.clones) do
                        if (obj) then obj:Destroy() end
                    end

                    esp[plr].box.holder:Destroy()
                    esp[plr].chams.model:Destroy()
                    esp[plr].chams.always_on_top:Destroy()
                    esp[plr].chams.occluded:Destroy()
                    esp[plr] = nil
                end;
            end;
            
            -- UI Controls
            local stRespawnConn
            
            local toggle = SeeThroughSection:toggle({
                name = "Enabled",
                flag = "st_enabled",
                default = false,
                callback = function(v)
                    stLibrary.chams.enabled = v
                    if v then
                        esp.add(players.LocalPlayer)
                        
                        if stRespawnConn then stRespawnConn:Disconnect() end
                        stRespawnConn = players.LocalPlayer.CharacterAdded:Connect(function(newChar)
                            -- Force clear old ESP immediately on respawn
                            esp.remove(players.LocalPlayer)
                            
                            newChar:WaitForChild("HumanoidRootPart")
                            task.wait(0.5)
                            if stLibrary.chams.enabled then
                                esp.add(players.LocalPlayer)
                            end
                        end)
                    else
                        esp.remove(players.LocalPlayer)
                        if stRespawnConn then stRespawnConn:Disconnect() stRespawnConn = nil end
                    end
                end
            })
            
            -- Apply Black/White Scheme (Original seethrough.txt defaults)
            stLibrary.chams.colors.visible = Color3.fromRGB(0, 0, 0)
            stLibrary.chams.colors.occluded = Color3.fromRGB(255, 255, 255)
            stLibrary.chams.transparency.visible = 0.5
            stLibrary.chams.transparency.occluded = 0

            SeeThroughSection:colorpicker({
                name = "Visible Color",
                flag = "st_vis_col",
                color = stLibrary.chams.colors.visible,
                callback = function(c) stLibrary.chams.colors.visible = c end
            })
            SeeThroughSection:slider({
                name = "Visible Transparency",
                flag = "st_vis_trans",
                min = 0, max = 1, default = 0.5, decimal = 0.1,
                callback = function(v) stLibrary.chams.transparency.visible = v end
            })
            
            SeeThroughSection:colorpicker({
                name = "Occluded Color",
                flag = "st_occ_col",
                color = stLibrary.chams.colors.occluded,
                callback = function(c) stLibrary.chams.colors.occluded = c end
            })
            SeeThroughSection:slider({
                name = "Occluded Transparency",
                flag = "st_occ_trans",
                min = 0, max = 1, default = 0, decimal = 0.1,
                callback = function(v) stLibrary.chams.transparency.occluded = v end
            })
        end

        do -- Left Column: Lighting
            local LightingSection = visualsLeft:section({name = "Lighting"})
            do
                local ambient = LightingSection:toggle({name = "Ambience", flag = "visuals_ambient", default = false, callback = function() end})
                ambient:colorpicker({flag = "visuals_ambient_outdoor", color = Color3.fromRGB(255, 255, 255), callback = function() end}) -- OutdoorAmbient
                ambient:colorpicker({flag = "visuals_ambient_indoor", color = Color3.fromRGB(255, 255, 255), callback = function() end}) -- Ambient
            end
            
            do
                local tintToggle = LightingSection:toggle({name = "Tint", flag = "visuals_tint", default = false, callback = function() end})
                tintToggle:colorpicker({flag = "visuals_tint_color", color = Color3.fromRGB(191, 191, 244), callback = function() end})
            end
            
            LightingSection:toggle({name = "Color Correction", flag = "visuals_cc", default = false, callback = function() end})
            LightingSection:slider({name = "Saturation", flag = "visuals_cc_saturation", min = -2, max = 2, default = 0, suffix = "", decimal = 0.1, callback = function() end})
            LightingSection:slider({name = "Contrast", flag = "visuals_cc_contrast", min = -1, max = 1, default = 0, suffix = "", decimal = 0.1, callback = function() end})
            LightingSection:slider({name = "Brightness", flag = "visuals_cc_brightness", min = 0, max = 1, default = 0, suffix = "", decimal = 0.1, callback = function() end})

            LightingSection:toggle({name = "Brightness", flag = "visuals_brightness", default = false, callback = function() end})

            -- Lighting Logic Implementation
            local lighting = game:GetService("Lighting")
            local lighting_save = {
                Ambient = lighting.Ambient,
                OutdoorAmbient = lighting.OutdoorAmbient,
                FogColor = lighting.FogColor,
                FogEnd = lighting.FogEnd,
                FogStart = lighting.FogStart,
                ClockTime = lighting.ClockTime,
                Brightness = lighting.Brightness
            }
            
            RunService.RenderStepped:Connect(function()
                -- Ambience
                if library.flags.visuals_ambient then
                    lighting.Ambient = getFlagColor(library.flags.visuals_ambient_outdoor, lighting_save.Ambient)
                    lighting.OutdoorAmbient = getFlagColor(library.flags.visuals_ambient_indoor, lighting_save.OutdoorAmbient)
                else
                    lighting.Ambient = lighting_save.Ambient
                    lighting.OutdoorAmbient = lighting_save.OutdoorAmbient
                end
                
                -- Color Correction
                local cc = lighting:FindFirstChild("TraeColorCorrection")
                local tintEnabled = library.flags.visuals_tint
                local ccEnabled = library.flags.visuals_cc
                
                if tintEnabled or ccEnabled then
                    if not cc then
                        cc = Instance.new("ColorCorrectionEffect")
                        cc.Name = "TraeColorCorrection"
                        cc.Parent = lighting
                    end
                    cc.Enabled = true
                    
                    if ccEnabled then
                        cc.Saturation = library.flags.visuals_cc_saturation or 0
                        cc.Contrast = library.flags.visuals_cc_contrast or 0
                        cc.Brightness = library.flags.visuals_cc_brightness or 0
                    else
                        cc.Saturation = 0
                        cc.Contrast = 0
                        cc.Brightness = 0
                    end
                    
                    if tintEnabled then
                        cc.TintColor = getFlagColor(library.flags.visuals_tint_color, Color3.new(1, 1, 1))
                    else
                        cc.TintColor = Color3.new(1, 1, 1)
                    end
                else
                    if cc then cc.Enabled = false end
                end
                
                -- Brightness (Fullbright)
                if library.flags.visuals_brightness then
                    lighting.Brightness = 2
                    lighting.ClockTime = 14
                    lighting.FogEnd = 100000
                    lighting.GlobalShadows = false
                else
                    lighting.Brightness = lighting_save.Brightness
                    lighting.ClockTime = lighting_save.ClockTime
                    lighting.FogEnd = lighting_save.FogEnd
                end
            end)
        end

        do -- Right Column: Crosshair
            local CrosshairSection = visualsRight:section({name = "Crosshair"})

            -- Helper to ensure Color3 type
            local function ensureColor3(col)
                if typeof(col) == "Color3" then return col end
                if type(col) == "table" then
                    if col.r then return Color3.new(col.r, col.g, col.b) end -- Assuming 0-1 range if table has r,g,b
                    if col[1] then return Color3.new(col[1], col[2], col[3]) end
                end
                return Color3.fromRGB(191, 191, 244) -- Fallback
            end

            do
                local visible = CrosshairSection:toggle({name = "Enabled", flag = "visuals_crosshair_visible", default = false, callback = function(v)
                    if getgenv().crosshair then getgenv().crosshair.enabled = v end
                end})
                visible:colorpicker({flag = "visuals_crosshair_color", color = Color3.fromRGB(191, 191, 244), callback = function(v)
                    if getgenv().crosshair then getgenv().crosshair.color = ensureColor3(v) end
                end})
            end

            -- Position Dropdown Removed (Hardcoded to Center)

            CrosshairSection:slider({name = "Width", flag = "visuals_crosshair_thickness", min = 1, max = 10, default = 1, suffix = "", callback = function(v)
                if getgenv().crosshair then getgenv().crosshair.width = v end
            end})
            CrosshairSection:slider({name = "Length", flag = "visuals_crosshair_length", min = 0, max = 50, default = 10, suffix = "", callback = function(v)
                if getgenv().crosshair then getgenv().crosshair.length = v end
            end})
            CrosshairSection:slider({name = "Radius", flag = "visuals_crosshair_gap", min = 0, max = 50, default = 10, suffix = "", callback = function(v)
                if getgenv().crosshair then getgenv().crosshair.radius = v end
            end})
            
            local spinSpeed
            local resizeToggle
            local resizeSpeed
            local resizeMax
            local resizeMin

            CrosshairSection:toggle({name = "Spin", flag = "visuals_crosshair_spin", default = false, callback = function(v)
                if getgenv().crosshair then getgenv().crosshair.spin = v end
            end})
            
            spinSpeed = CrosshairSection:slider({name = "Spin Speed", flag = "visuals_crosshair_spin_speed", min = 0, max = 340, default = 85, suffix = "", callback = function(v)
                if getgenv().crosshair then getgenv().crosshair.spin_speed = v end
            end})

            resizeToggle = CrosshairSection:toggle({name = "Resize", flag = "visuals_crosshair_resize", default = false, callback = function(v)
                if getgenv().crosshair then getgenv().crosshair.resize = v end
            end})
            
            resizeSpeed = CrosshairSection:slider({name = "Resize Speed", flag = "visuals_crosshair_resize_speed", min = 1, max = 50, default = 50, suffix = "", callback = function(v)
                if getgenv().crosshair then getgenv().crosshair.resize_speed = v end
            end})
            resizeMax = CrosshairSection:slider({name = "Resize Max", flag = "visuals_crosshair_max", min = 0, max = 50, default = 10, suffix = "", callback = function(v)
                if getgenv().crosshair then getgenv().crosshair.resize_max = v end
            end})
            resizeMin = CrosshairSection:slider({name = "Resize Min", flag = "visuals_crosshair_min", min = 0, max = 50, default = 10, suffix = "", callback = function(v)
                if getgenv().crosshair then getgenv().crosshair.resize_min = v end
            end})

            -- Load and Sync Crosshair Library (After UI creation to ensure flags exist)
            task.spawn(function()
                pcall(function()
                    -- Force load the library to ensure render loop is running
                    loadstring(game:HttpGet('https://raw.githubusercontent.com/hiddenassets5555/frontlines/refs/heads/main/a', true))()

                    if getgenv().crosshair then
                        -- Wait a moment for flags to be registered if needed, though they should be ready
                        -- task.wait(0.1) -- Removed to prevent flash
                        local flags = library.flags
                        
                        -- Sync Enabled
                        if flags.visuals_crosshair_visible ~= nil then
                            getgenv().crosshair.enabled = flags.visuals_crosshair_visible
                        else
                            getgenv().crosshair.enabled = false -- Default to false
                        end

                        -- Sync Color
                        if flags.visuals_crosshair_color then
                            getgenv().crosshair.color = ensureColor3(flags.visuals_crosshair_color)
                        else
                            getgenv().crosshair.color = Color3.fromRGB(191, 191, 244)
                        end
                        
                        -- Force Center Mode
                        getgenv().crosshair.mode = 'center'
                        
                        -- Sync Dimensions
                        if flags.visuals_crosshair_thickness then getgenv().crosshair.width = flags.visuals_crosshair_thickness end
                        if flags.visuals_crosshair_length then getgenv().crosshair.length = flags.visuals_crosshair_length end
                        if flags.visuals_crosshair_gap then getgenv().crosshair.radius = flags.visuals_crosshair_gap end
                        
                        -- Sync Spin
                        if flags.visuals_crosshair_spin ~= nil then 
                            getgenv().crosshair.spin = flags.visuals_crosshair_spin 
                        else
                            getgenv().crosshair.spin = false
                        end
                        if flags.visuals_crosshair_spin_speed then getgenv().crosshair.spin_speed = flags.visuals_crosshair_spin_speed end
                        
                        -- Sync Resize
                        if flags.visuals_crosshair_resize ~= nil then 
                            getgenv().crosshair.resize = flags.visuals_crosshair_resize 
                        else
                            getgenv().crosshair.resize = false
                        end
                        if flags.visuals_crosshair_resize_speed then getgenv().crosshair.resize_speed = flags.visuals_crosshair_resize_speed end
                        if flags.visuals_crosshair_max then getgenv().crosshair.resize_max = flags.visuals_crosshair_max end
                        if flags.visuals_crosshair_min then getgenv().crosshair.resize_min = flags.visuals_crosshair_min end
                    end
                end)
            end)
        end

        do -- Right Column: Camera
            local CameraSection = visualsRight:section({name = "Camera"})
            do
                local freecam = CameraSection:toggle({name = "Freecam", flag = "visuals_freecam", default = false, callback = function() end})
                freecam:keybind({name = "Freecam Key", flag = "visuals_freecam_key", default = Enum.KeyCode.RightShift, callback = function() end})
            end
            CameraSection:slider({name = "Speed", flag = "visuals_freecam_speed", min = 1, max = 100, default = 20, suffix = "", callback = function() end})

            CameraSection:toggle({name = "Field of View", flag = "visuals_fov", default = false, callback = function() end})
            CameraSection:slider({name = "Amount", flag = "visuals_fov_amount", min = 1, max = 120, default = 70, suffix = "", callback = function() end})

            do
                local zoom = CameraSection:toggle({name = "Zoom", flag = "visuals_zoom", default = false, callback = function() end})
                zoom:keybind({name = "Zoom Key", flag = "visuals_zoom_key", default = Enum.KeyCode.Z, callback = function() end})
            end
        end
    end)()

library:config_list_update()
for index, value in themes.preset do 
pcall(function()
    library:update_theme(index, value)
end)
end
task.wait()
library.old_config = library:get_config()

local lighting = game:GetService("Lighting")
local lighting_save = {
    Ambient = lighting.Ambient,
    OutdoorAmbient = lighting.OutdoorAmbient,
    FogColor = lighting.FogColor,
    FogEnd = lighting.FogEnd,
    FogStart = lighting.FogStart
}

-- SCP Viewport Sync Loop
run.RenderStepped:Connect(function()
    if flags.esp_enabled_dummy then
        -- Update SCP Highlight Breathing (Thermal Effect)
        local breathe = 0.5 + (0.3 * math.sin(tick() * 5))
        
        -- Check Dropdown Options
        local options = flags.scp_options_dummy or {}
        local useThermal = false
        local forceSee = false
        if type(options) == "table" then
             for _, v in pairs(options) do
                 if v == "ForceThermal" then useThermal = true end
                 if v == "ForceSee" then forceSee = true end
             end
        end
        
        local showHighlight = flags.scp_chams_toggle
        if forceSee then showHighlight = false end

        for _, hl in pairs(SCPESPCache) do
            if hl and hl.Parent then
                 if not showHighlight then
                     hl.FillTransparency = 1
                     hl.OutlineTransparency = 1
                 else
                     if useThermal then
                         hl.FillTransparency = breathe
                         hl.OutlineTransparency = 0 
                     else
                         hl.FillTransparency = 0.5
                         hl.OutlineTransparency = 0
                     end
                     hl.FillColor = getFlagColor(flags.scp_chams_fill_color, Color3.fromRGB(218, 81, 157))
                     hl.OutlineColor = getFlagColor(flags.scp_chams_outline_color, Color3.new(0,0,0))
                 end
            end
        end
        
        -- Sync Viewport Camera
        if ViewportCamera then
             ViewportCamera.CFrame = camera.CFrame
             ViewportCamera.FieldOfView = camera.FieldOfView
        end

        for original, clone in pairs(SCPViewportCache) do
            if original and original.Parent and clone and clone.Parent then
                -- Sync Main Position
                clone:PivotTo(original:GetPivot())
                
                -- Sync Limbs/Parts/Bones for Animation
                local function syncRecursive(oObj, cObj)
                    for _, oChild in ipairs(oObj:GetChildren()) do
                        local cChild = cObj:FindFirstChild(oChild.Name)
                        if cChild then
                            if oChild:IsA("BasePart") and cChild:IsA("BasePart") then
                                cChild.CFrame = oChild.CFrame
                                -- Sync Visuals (Color, Transparency) to keep "Actual SCP" look
                                if cChild.Name ~= "HumanoidRootPart" and cChild ~= clone.PrimaryPart then
                                    cChild.Color = oChild.Color
                                    cChild.Material = oChild.Material
                                    cChild.Transparency = oChild.Transparency
                                    
                                    -- Optional: Apply thermal transparency breathing if enabled
                                    if useThermal then
                                        cChild.Transparency = breathe
                                    end
                                end
                            elseif oChild:IsA("Bone") and cChild:IsA("Bone") then
                                cChild.CFrame = oChild.CFrame
                                cChild.Rotation = oChild.Rotation
                            end
                            syncRecursive(oChild, cChild)
                        end
                    end
                end
                
                syncRecursive(original, clone)
            else
                if clone then clone:Destroy() end
                SCPViewportCache[original] = nil
            end
        end
    end
end)

